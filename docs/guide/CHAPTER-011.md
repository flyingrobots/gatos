# Chapter 11: Performance: Partial Folds, Caching, and Exploration

<a id="chapter-11-performance-partial-folds-caching-and-exploration"></a>

<!-- AUTOGENERATED TOC START -->

- [Partial and Lazy Folds](#partial-and-lazy-folds)
- [The Cache Plane and Explorer Off-Ramps](#the-cache-plane-and-explorer-off-ramps)
  - [The Cache Plane](#the-cache-plane)
    - [Cache Keys and Correctness](#cache-keys-and-correctness)
  - [GATOS-to-SQL/Parquet Explorer](#gatos-to-sql-parquet-explorer)
    - [Recommended Git config for big repos](#recommended-git-config-for-big-repos)
    - [Cache Invalidation Strategy](#cache-invalidation-strategy)
    - [Roaring Indexing](#roaring-indexing)
- [Summary](#summary)

<!-- AUTOGENERATED TOC END -->

<a id="chapter-11-performance-partial-folds-caching-and-exploration"></a>

A common concern with systems that rely on immutable history and deterministic replay is performance. If every state change requires re-processing the entire history of the system, how can it possibly scale?

GATOS is designed from the ground up to be performant at scale. It achieves this through a combination of clever algorithms, a dedicated cache plane, and by providing tools to explore and analyze the data in more efficient formats.

## Partial and Lazy Folds

<a id="partial-and-lazy-folds"></a>
The key to GATOS's performance is that it rarely needs to re-fold the entire history of the universe. The **GATOS Morphology Calculus** (as described in [Chapter 9](./CHAPTER-009.md)) provides the theoretical foundation for this with **Theorem 2 (Localization & Incrementality)**.

This theorem states that if the system's history can be broken down into independent regions (i.e., sets of events that don't have overlapping read/write sets), then the state of the whole is simply the composition of the states of the parts.

In practice, this means GATOS can perform **partial and lazy folds**:

- **Partial Folds:** When a new event comes in, the system can analyze its "footprint" (the data it reads from and writes to) and determine which part of the state graph is affected. It only needs to re-fold that small, relevant partition of the event history.
- **Lazy Folds:** Not all state needs to be computed all the time. GATOS can defer the folding of certain parts of the state until they are actually requested.

This makes the cost of a state update proportional to the size of the change, not the size of the entire history.

## The Cache Plane and Explorer Off-Ramps

<a id="the-cache-plane-and-explorer-off-ramps"></a>
To further optimize performance, GATOS includes a dedicated **Cache Plane** and provides "off-ramps" to traditional data exploration tools. These are secondary, non-authoritative views of the data, derived deterministically from the Ledger.

```mermaid
graph TD
    subgraph "Authoritative Core"
        A[Ledger Plane] --> B{State Plane Fold};
        B --> C[State Root];
    end

    subgraph "Performance & Exploration Layers"
        B --> D[Cache Plane];
        D --> E[Roaring Bitmap Indexes];
        B --> F[Explorer Off-Ramp];
        F --> G[SQL Database / Parquet Files];
    end

    style A fill:#c99,stroke:#333,stroke-width:2px
    style B fill:#9cf,stroke:#333,stroke-width:2px
    style C fill:#9cf,stroke:#333,stroke-width:2px
    style D fill:#f9e79f,stroke:#333,stroke-width:2px
    style E fill:#f9e79f,stroke:#333,stroke-width:2px
    style F fill:#a9cce3,stroke:#333,stroke-width:2px
    style G fill:#a9cce3,stroke:#333,stroke-width:2px
```

### The Cache Plane

<a id="the-cache-plane"></a>

- **Location:** The cache lives under the `refs/gatos/cache/` refspace in Git.
- **Content:** The cache can store various artifacts, but its most important content is indexes built from **Roaring Bitmaps**.
- **Roaring Bitmaps:** These are highly compressed, efficient data structures for storing and performing operations on large sets of integers. The GATOS indexer processes the event journal and creates roaring bitmap indexes for fast querying (e.g., "find all events related to user X").

Because the cache is just a result of a deterministic fold, it can be safely deleted and rebuilt at any time. It is a pure optimization and not part of the authoritative state of the system.

#### Cache Keys and Correctness

<a id="cache-keys-and-correctness"></a>
Top-level cache keys MUST include:

- `ledger_head`
- `policy_root`
- `fold_engine_id` (e.g., `echo@0.7.3`)
- `fold_version` (e.g., `gatos-echo-fold@1`)

Partial/unit caches (ADR-0013) SHOULD derive keys such as:

- `Unit-Key = blake3(code_hash || policy_root || …)`

### GATOS-to-SQL/Parquet Explorer

<a id="gatos-to-sql-parquet-explorer"></a>
While the Git-native storage of GATOS is perfect for auditability and distribution, it is not always the most efficient format for large-scale analytical queries. For this, GATOS provides an **explorer** or **"off-ramp"** mechanism.

A dedicated process can be configured to follow the GATOS ledger and deterministically transform the event data into a more traditional analytical format, such as:

- A **SQL database** (e.g., PostgreSQL or DuckDB).
- A set of **Parquet files** in a data lake.

This allows standard business intelligence (BI) tools, dashboards, and data science notebooks to run complex analytical queries over the GATOS data without having to understand the underlying Git-based storage model.

Explorer views are read-only. Provide a canonical checksum:

```
Explorer-Root = blake3(ledger_head || policy_root || extractor_version)
```

#### Recommended Git config for big repos

<a id="recommended-git-config-for-big-repos"></a>

```
git config --global fetch.writeCommitGraph true
git config --global repack.writeBitmaps true
git config --global repack.packKeptObjects false
```

Consider partial clone and promisor remotes for `refs/gatos/mbus/*`.

#### Cache Invalidation Strategy

<a id="cache-invalidation-strategy"></a>

1. Build a footprint map tracking which cache segments depend on which event ranges.
2. On new events, compute impacted regions by intersecting the event's read/write set with the footprint map.
3. Drop those cache segments.
4. Re-fold only the impacted units on next query.

#### Roaring Indexing

<a id="roaring-indexing"></a>
Index by ULID time, entity id, and event type:

- Time dimension: Extract millisecond epoch from ULID prefix (48 bits), truncate to suitable granularity (for example, hour buckets).
- Entity dimension: Maintain a stable id→int mapping persisted in cache metadata.
- Event type dimension: Use a fixed enum or a hash-to-int mapping with collision handling.

Encodings must be deterministic and versioned to maintain cache correctness across fold engine updates.

The key is that this transformation is itself a **deterministic fold**. The analytical database is a secondary, verifiable view of the primary data in the ledger. You can always rebuild it from scratch and get the exact same result.

## Summary

<a id="summary"></a>
GATOS is designed for both correctness and performance. It achieves high performance not by cutting corners on its guarantees, but by applying its core principles of determinism and mathematical rigor to the problem of optimization.

- **Partial and Lazy Folds** make state updates efficient by minimizing re-computation.
- **The Cache Plane** provides rebuildable, high-speed indexes for fast queries.
- **Explorer Off-ramps** bridge the gap to the traditional world of data analytics, providing a verifiable, read-optimized view of the GATOS ledger.

This combination allows GATOS to serve as both a high-integrity transactional system and a high-performance analytical backend, without compromising on its core principles.
