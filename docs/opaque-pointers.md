---
title: Opaque Pointers — Privacy by Construction
---

# Opaque Pointers — Privacy by Construction

<a id="opaque-pointers--privacy-by-construction"></a>

<a id="opaque-pointers--privacy-by-construction"></a>

<a id="opaque-pointers-privacy-by-construction"></a>

<a id="opaque-pointers--privacy-by-construction"></a>

<a id="opaque-pointers--privacy-by-construction"></a><a id="opaque-pointers-privacy-by-construction"></a>

<!-- AUTOGENERATED TOC START -->

- [Public Pointer Rules (Normative)](#public-pointer-rules-normative)
- [Availability & Resolver](#availability--resolver)
- [Projection Determinism](#projection-determinism)
- [BAA — Blob Availability Attestation](#baa--blob-availability-attestation)

<!-- AUTOGENERATED TOC END -->

Opaque Pointers allow public verification with private bytes.

## Public Pointer Rules (Normative)

<a id="public-pointer-rules-normative"></a>

<a id="public-pointer-rules-normative"></a>

<a id="public-pointer-rules-normative"></a>

See [[[[[SPEC §7](/SPEC#7)](/SPEC#7)](/SPEC#7)](/SPEC#7)](/SPEC#7) and Research Profile §12.1.

- Pointer envelopes **MUST** use Canonical JSON with `kind: "opaque_pointer"`, `algo: "blake3"`, `digest: blake3:<hex>`, optional bucketed `size`, and URIs for `location` + `capability`.
- `digest` is the BLAKE3 hash of the raw plaintext blob. Plaintext bytes never enter Git; digest collisions or dictionary attacks are mitigated by policy (use opaque pointers for any low-entropy data).
- `location` declares where to fetch the blob (`gatos-node://`, `https://`, `s3://`, `ipfs://`, `file:///` dev/test). `capability` declares how to authorize/decrypt (`gatos-key://`, `kms://`, `age://`, etc.).
- Pointer `size` metadata **SHOULD** use coarse buckets (e.g., 1 KB, 4 KB, 16 KB, 64 KB) to avoid leaking exact lengths.
- Envelope `content_id = blake3(canonical_bytes)` and MUST be stable across projections.

## Availability & Resolver

<a id="availability--resolver"></a>

<a id="availability--resolver"></a>

<a id="availability-resolver"></a>

<a id="availability--resolver"></a>

<a id="availability--resolver"></a><a id="availability-resolver"></a>
Resolvers serve private bytes to authorized clients. They MUST:

1. Parse the `location` URI to determine how to fetch the encrypted blob. For `gatos-node://ed25519:<pubkey>`, resolve the node via the trust graph and fetch `GET /.well-known/gatos/private/{digest}`. For HTTP/S3/IPFS/file URIs, use the obvious client.
2. Require authorization via the declared `capability` (default profile: Bearer JWT). Log every decision under `refs/gatos/audit/` and enforce JWT claims (`sub`, `aud`, `exp`, optional `scope`). Other schemes like KMS, AGE, or HTTP message signatures MAY be layered on.
3. After decrypting, compute `blake3(plaintext)` and compare against the pointer’s `digest`. Respond with `Digest: blake3=<hex>`/`X-BLAKE3-Digest: <hex>` headers so clients can double-check integrity. Resolution MUST fail on any mismatch.

## Projection Determinism

<a id="projection-determinism"></a>

<a id="projection-determinism"></a>

<a id="projection-determinism"></a>

Folds operate on pointer shapes, not plaintext bytes. Any materialized computation over decrypted data runs in jobs (PoE) and contributes to PoF/PoX rather than the public fold itself.

## BAA — Blob Availability Attestation

<a id="baa--blob-availability-attestation"></a>

<a id="baa--blob-availability-attestation"></a>

<a id="baa-blob-availability-attestation"></a>

<a id="baa--blob-availability-attestation"></a>

<a id="baa--blob-availability-attestation"></a><a id="baa-blob-availability-attestation"></a>

```json
{ "blob": "blake3:<hex>", "store": "s3://bucket/path", "retain_until": "2026-01-01T00:00:00Z", "sig": "ed25519:<base64>" }
```

Policies can require a valid BAA before accepting pointers into state.
