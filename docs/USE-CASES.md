# GATOS — USE CASES

<!-- AUTOGENERATED TOC START -->

- [1) Programmable Git (Policy-Enforced Repos)](#1)
- [2) Distributed State Machines (Deterministic)](#2)
- [3) Distributed General Computer (Agents on a Bus)](#3)
- [4) Supply-Chain & Deploy Attestation](#4)
- [5) Air-Gapped ML Registry](#5)
- [6) Cross-App Data Sharing (RLS-gated)](#6)
- [7) Knowledge Graph for Code & Ops](#7)
- [8) Regulated Feature Flags & Config](#8)

<!-- AUTOGENERATED TOC END -->

<a id="gatos-use-cases"></a>

> *Have **you** tried GATOS yet?*

This document illustrates practical scenarios where GATOS provides unique value.

---

## 1) Programmable Git (Policy-Enforced Repos)

<a id="1"></a><a id="1-programmable-git-policy-enforced-repos"></a>

| | |
|---|---|
|**Goal** | Treat Git as a programmable ledger with rule-checked writes. |
| **How** | Journals under `refs/gatos/journal/**`, policy gate enforces who/what/where, audits on deny. |
| **Why GATOS** | No server required (local), or push-gate profile for RYW and centralized enforcement. |

---

## 2) Distributed State Machines (Deterministic)

<a id="2"></a><a id="2-distributed-state-machines-deterministic"></a>

| | |
|---|---|
|**Goal** | Model business processes as append-only events → deterministic state. |
| **How** | Echo folds compute `state_root`; checkpoints under `refs/gatos/state/**`. |
| **Why GATOS** | Any node can replay to the same byte-identical result; offline-first. |

---

## 3) Distributed General Computer (Agents on a Bus)

<a id="3"></a><a id="3-distributed-general-computer-agents-on-a-bus"></a>

| | |
|---|---|
|**Goal** | Multi-agent orchestration with exactly-once semantics and audit. |
| **How** | Git message bus (`refs/gatos/mbus/**`) with acks/commitments; capabilities gate topics. |
| **Why GATOS** | Works without Kafka; merges cleanly; persists forever. |

---

## 4) Supply-Chain & Deploy Attestation

<a id="4"></a><a id="4-supply-chain-deploy-attestation"></a>

| | |
|---|---|
|**Goal** | Immutable, signed, verifiable deploy records. |
| **How** | Ship every critical action as an event; store stdout/stderr as notes; multi-sig trust for policy changes. |
| **Why GATOS** | Incident response + compliance with zero vendor lock. |

---

## 5) Air-Gapped ML Registry

<a id="5"></a><a id="5-air-gapped-ml-registry"></a>

| | |
|---|---|
|**Goal** | Version large models/datasets with provenance and selective export. |
| **How** | Opaque pointers for ciphertext artifacts; policies for export; epochs bound repo growth. |
| **Why GATOS** | Portable archives; verifiable lineage; offline friendly. |

---

## 6) Cross-App Data Sharing (RLS-gated)

<a id="6"></a><a id="6-cross-app-data-sharing-rls-gated"></a>

| | |
|---|---|
|**Goal** | App A reads materialized state from App B without custom APIs. |
| **How** | App B publishes state under `refs/gatos/state/<ns>`; App A fetches and enforces RLS via shared policy bundles. |
| **Why GATOS** | Zero glue code; shared Merkle truth. |

---

## 7) Knowledge Graph for Code & Ops

<a id="7"></a><a id="7-knowledge-graph-for-code-ops"></a>

| | |
|---|---|
|**Goal** | Persist “why” relationships alongside “what” code changes. |
| **How** | Edges as journal events; roaring-bitmap caches for fast queries. |
| **Why GATOS** | Time-travelable semantics baked into Git. |

---

## 8) Regulated Feature Flags & Config

<a id="8"></a><a id="8-regulated-feature-flags-config"></a>

| | |
|---|---|
|**Goal** | Signed toggles with audit and rollbacks. |
| **How** | KV-style events + index refs; push-gate for enforcement. |
| **Why GATOS** | Auditable configuration without a new database. |
