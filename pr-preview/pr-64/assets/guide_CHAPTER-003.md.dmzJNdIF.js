import{_ as t,c as o,o as a,a3 as s}from"./chunks/framework.BXNB9gP7.js";const r="/gatos/pr-preview/pr-64/assets/docs_guide_CHAPTER-003__1887d86952__mermaid_1.BO47aFH-.svg",i="/gatos/pr-preview/pr-64/assets/docs_guide_CHAPTER-003__1887d86952__mermaid_2.DiWjDsl6.svg",u=JSON.parse('{"title":"Chapter 3: The State Plane: Deterministic Folds","description":"","frontmatter":{},"headers":[],"relativePath":"guide/CHAPTER-003.md","filePath":"guide/CHAPTER-003.md","lastUpdated":1763133914000}'),n={name:"guide/CHAPTER-003.md"};function c(l,e,h,d,p,g){return a(),o("div",{"data-pagefind-body":!0},[...e[0]||(e[0]=[s('<h1 id="chapter-3-the-state-plane-deterministic-folds" tabindex="-1">Chapter 3: The State Plane: Deterministic Folds <a class="header-anchor" href="#chapter-3-the-state-plane-deterministic-folds" aria-label="Permalink to &quot;Chapter 3: The State Plane: Deterministic Folds&quot;">​</a></h1><p><a id="chapter-3-the-state-plane-deterministic-folds"></a></p><ul><li><a href="#the-fold-from-history-to-state">The Fold: From History to State</a></li><li><a href="#the-echo-engine-gatos-echo">The Echo Engine: <code>gatos-echo</code></a><ul><li><a href="#concurrency-and-state-transitions">Concurrency and State Transitions</a></li></ul></li><li><a href="#the-key-value-store-gatos-kv">The Key-Value Store: <code>gatos-kv</code></a></li><li><a href="#state-checkpoints">State Checkpoints</a><ul><li><a href="#checkpoint-trailers-recommended">Checkpoint Trailers (Recommended)</a></li><li><a href="#tiny-dpo-example">Tiny DPO Example</a></li></ul></li><li><a href="#summary">Summary</a></li></ul><p><a id="chapter-3-the-state-plane-deterministic-folds"></a></p><p><img src="https://github.com/user-attachments/assets/d80a6eb7-52a9-4a13-b137-44f089d7f63a" alt="gatos-lazy-folds"></p><blockquote><p><em>Folding the Operating Surface into new shapes</em></p></blockquote><p>The Ledger Plane provides an immutable history of every event that has ever occurred. However, a raw event log is not always a useful representation of the <em>current</em> state of the world. The role of the <strong>State Plane</strong> is to process this event log and compute a single, canonical, and verifiable snapshot of the system&#39;s state at a given point in time.</p><p>This process is called a <strong>fold</strong>. A fold takes the linear history of the ledger and, like origami, creases and transforms it into a new, complex, and meaningful <strong>shape</strong>.</p><h2 id="the-fold-from-history-to-state" tabindex="-1">The Fold: From History to State <a class="header-anchor" href="#the-fold-from-history-to-state" aria-label="Permalink to &quot;The Fold: From History to State&quot;">​</a></h2><p><a id="the-fold-from-history-to-state"></a> A fold is a pure, <strong>deterministic</strong> function that takes two inputs:</p><ol><li>A stream of events from the Ledger Plane.</li><li>A specific version of the system&#39;s policies from the Policy Plane.</li></ol><p>It processes these events in order and produces a single output: a <strong>state root</strong>, which is the cryptographic hash of the resulting state shape.</p><figure><img src="'+r+'" alt="diagram 1" loading="lazy"></figure><p>The key property of a fold is its determinism. Given the exact same sequence of events and the same policy, the fold function <strong>must</strong> always produce the exact same state root, bit for bit. Same ledger and same <code>policy_root</code> ⇒ same <code>state_root</code>. This is the guarantee that allows GATOS to be a distributed system without requiring a central coordinator. Any node can independently and verifiably compute the state of the system by simply replaying the public ledger.</p><h2 id="the-echo-engine-gatos-echo" tabindex="-1">The Echo Engine: <code>gatos-echo</code> <a class="header-anchor" href="#the-echo-engine-gatos-echo" aria-label="Permalink to &quot;The Echo Engine: `gatos-echo`&quot;">​</a></h2><p><a id="the-echo-engine-gatos-echo"></a> For complex, relational state, GATOS uses the powerful <a href="https://github.com/flyingrobots/echo" target="_blank" rel="noreferrer"><strong>Echo</strong> engine</a>, provided by the <strong><code>gatos-echo</code></strong> crate. As we&#39;ll see in the chapter on the <a href="./CHAPTER-009.html">GATOS Morphology Calculus</a>, Echo is a <strong>deterministic simulation engine</strong> built on the concept of a <strong>Recursive Metagraph (RMG)</strong> and <strong>Double Push-Out (DPO) graph rewriting</strong>.</p><p>In the context of the GATOS State Plane, Echo works as follows:</p><ol><li><strong>State as a Graph:</strong> The &quot;world&quot; is represented as a graph within the Echo engine&#39;s <code>GraphStore</code>. This graph <em>is</em> the operating surface.</li><li><strong>Events as Rewrites:</strong> Each event from the ledger is translated into one or more graph rewrite rules. For example, a <code>user.create</code> event becomes a rule that adds a new <code>user</code> node and its associated property edges to the graph.</li><li><strong>Folding as Committing:</strong> The Echo engine&#39;s <code>DeterministicScheduler</code> orders these rewrites and applies them to the graph. The <code>commit()</code> operation finalizes these changes, creating a new shape.</li><li><strong>State Root as Snapshot Hash:</strong> After the commit, Echo produces a <code>Snapshot</code> of the new graph state. The cryptographic hash of this snapshot is the GATOS <strong>state root</strong>.</li></ol><p>This process, which GATOS refers to as a <strong>meld</strong>, is how the system evolves from one state to the next. When branches in the Git history are merged, the State Plane performs a meld — a deterministic fold-merge that reconciles two divergent shapes into one new, provably consistent shape.</p><h3 id="concurrency-and-state-transitions" tabindex="-1">Concurrency and State Transitions <a class="header-anchor" href="#concurrency-and-state-transitions" aria-label="Permalink to &quot;Concurrency and State Transitions&quot;">​</a></h3><p><a id="concurrency-and-state-transitions"></a> The <code>gatos-echo</code> engine manages state transitions with a precise understanding of concurrency, leveraging concepts like <strong>Footprints</strong>, <strong>Ports</strong>, and <strong>Epochs</strong>.</p><ul><li><strong>Footprints:</strong> Each rewrite rule declares its &quot;footprint,&quot; which is a precise description of the nodes, edges, and ports it intends to read from or write to. This allows the scheduler to detect potential conflicts.</li><li><strong>Ports:</strong> These represent boundary interfaces on nodes, allowing for fine-grained control over how rewrites interact. Two rewrites might touch different nodes but conflict if they try to access the same port on a shared boundary.</li><li><strong>Epochs:</strong> GATOS uses monotonically increasing 64-bit counters (<strong><code>epoch_att</code></strong> for attachments, <strong><code>epoch_skel</code></strong> for skeleton) to manage coherent world-rollovers. Readers are bound to specific epoch counters, ensuring they never witness a partially updated or &quot;torn&quot; state. Writers only advance epochs after all changes are published, guaranteeing snapshot isolation.</li></ul><p>The state transitions of a rewrite are managed through a series of phases:</p><figure><img src="'+i+`" alt="diagram 2" loading="lazy"></figure><ul><li><strong>Matched:</strong> A rewrite rule has found a pattern in the graph.</li><li><strong>Reserved:</strong> The rewrite has passed independence checks against all currently active (Reserved or Committed) rewrites. Its footprint is now part of the &quot;active frontier.&quot;</li><li><strong>Committed:</strong> The rewrite&#39;s changes have been atomically applied to the graph.</li><li><strong>Aborted:</strong> The rewrite failed independence checks or validation.</li></ul><h2 id="the-key-value-store-gatos-kv" tabindex="-1">The Key-Value Store: <code>gatos-kv</code> <a class="header-anchor" href="#the-key-value-store-gatos-kv" aria-label="Permalink to &quot;The Key-Value Store: \`gatos-kv\`&quot;">​</a></h2><p><a id="the-key-value-store-gatos-kv"></a> Not all state is complex and relational. For simpler configuration, flags, or object storage, GATOS provides a Git-backed key-value store, <strong><code>gatos-kv</code></strong>. This component is an evolution of the <code>git-kv</code> &quot;Stargate&quot; project.</p><p><code>gatos-kv</code> uses a different part of the Git repository (<code>refs/kv/*</code>) to store data. It provides an API for atomic <code>get</code>, <code>set</code>, and <code>mset</code> (multi-set) operations. While simpler than the Echo engine, it adheres to the same principles:</p><ul><li><strong>Ledger-Based:</strong> All writes to <code>gatos-kv</code> are still driven by events in the main GATOS ledger.</li><li><strong>Deterministic:</strong> The state of the key-value store is also a deterministic result of the event history.</li><li><strong>Verifiable:</strong> The entire KV store can be hashed to produce a verifiable state root.</li></ul><p>The State Plane can use <code>gatos-echo</code> and <code>gatos-kv</code> in combination, choosing the right tool for the right kind of state, while ensuring that the entire system state remains deterministic and verifiable.</p><h2 id="state-checkpoints" tabindex="-1">State Checkpoints <a class="header-anchor" href="#state-checkpoints" aria-label="Permalink to &quot;State Checkpoints&quot;">​</a></h2><p><a id="state-checkpoints"></a> The output of a fold is a <strong>State Checkpoint</strong>. This is a Git commit on a state ref (e.g., <code>refs/gatos/state/&lt;namespace&gt;</code>) that contains:</p><ul><li>The materialized state artifacts (e.g., the graph data for Echo, or the tree of key-value pairs for <code>gatos-kv</code>).</li><li>A reference to the commit in the Ledger Plane that this state was folded from.</li><li>The final, canonical <code>state_root</code> hash in its commit message or trailers.</li></ul><h3 id="checkpoint-trailers-recommended" tabindex="-1">Checkpoint Trailers (Recommended) <a class="header-anchor" href="#checkpoint-trailers-recommended" aria-label="Permalink to &quot;Checkpoint Trailers (Recommended)&quot;">​</a></h3><p><a id="checkpoint-trailers-recommended"></a></p><ul><li><code>State-Root: blake3:&lt;hex&gt;</code></li><li><code>Ledger-Head: &lt;commit-oid&gt;</code></li><li><code>Policy-Root: &lt;commit-oid&gt;</code></li><li><code>Fold-Engine: echo@&lt;semver&gt;</code></li><li><code>Fold-Version: &lt;schema-version&gt;</code></li></ul><p>You can verify a checkpoint with <code>git gatos fold verify</code> (see ADR-0014: Proof-of-Fold).</p><h3 id="tiny-dpo-example" tabindex="-1">Tiny DPO Example <a class="header-anchor" href="#tiny-dpo-example" aria-label="Permalink to &quot;Tiny DPO Example&quot;">​</a></h3><p><a id="tiny-dpo-example"></a> Before (subgraph):</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>User(id=42)</span></span>
<span class="line"><span>Email(user=42, value=&quot;a@example.org&quot;)</span></span></code></pre></div><p>Rule: <code>approve_user</code> — matches <code>User(id)</code> without <code>Approved(id)</code> and emits <code>Approved(id)</code>.</p><p>After (subgraph):</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>User(id=42)</span></span>
<span class="line"><span>Email(user=42, value=&quot;a@example.org&quot;)</span></span>
<span class="line"><span>Approved(id=42)</span></span></code></pre></div><p>These checkpoints provide an optimized way to access the current state without having to replay the entire event history every time. However, they are just a cache; the authoritative state can always be re-derived from the ledger.</p><h2 id="summary" tabindex="-1">Summary <a class="header-anchor" href="#summary" aria-label="Permalink to &quot;Summary&quot;">​</a></h2><p><a id="summary"></a> The State Plane is where the abstract history of the ledger is transformed into a concrete, queryable state. Through the deterministic fold process, the operating surface is given its new shape. Powered by the sophisticated <code>gatos-echo</code> graph engine and the practical <code>gatos-kv</code> store, GATOS ensures that all participants in the distributed system can independently arrive at a shared, verifiable understanding of reality.</p>`,46)])])}const f=t(n,[["render",c]]);export{u as __pageData,f as default};
