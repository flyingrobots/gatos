import{_ as o,c as t,o as a,a3 as r}from"./chunks/framework.BXNB9gP7.js";const i="/gatos/pr-preview/pr-64/assets/docs_guide_CHAPTER-009__1a8303293d__mermaid_1.BeZ2PM56.svg",s="/gatos/pr-preview/pr-64/assets/docs_guide_CHAPTER-009__1a8303293d__mermaid_2.Bu8kkoUA.svg",g=JSON.parse('{"title":"Chapter 9: The GATOS Morphology Calculus","description":"","frontmatter":{},"headers":[],"relativePath":"guide/CHAPTER-009.md","filePath":"guide/CHAPTER-009.md","lastUpdated":1763130792000}'),n={name:"guide/CHAPTER-009.md"};function c(l,e,h,d,u,p){return a(),t("div",{"data-pagefind-body":!0},[...e[0]||(e[0]=[r('<h1 id="chapter-9-the-gatos-morphology-calculus" tabindex="-1">Chapter 9: The GATOS Morphology Calculus <a class="header-anchor" href="#chapter-9-the-gatos-morphology-calculus" aria-label="Permalink to &quot;Chapter 9: The GATOS Morphology Calculus&quot;">​</a></h1><p><a id="chapter-9-the-gatos-morphology-calculus"></a></p><ul><li><a href="#core-objects">Core Objects</a></li><li><a href="#key-theorems-and-their-payoffs">Key Theorems and Their Payoffs</a><ul><li><a href="#theorem-1-deterministic-shape">Theorem 1: Deterministic Shape</a></li><li><a href="#theorem-2-localization-incrementality">Theorem 2: Localization &amp; Incrementality</a></li><li><a href="#theorem-3-safe-policy-migration">Theorem 3: Safe Policy Migration</a></li><li><a href="#theorem-4-mind-meld-as-a-pushout">Theorem 4: Mind-Meld as a Pushout</a></li><li><a href="#further-theorems">Further Theorems</a></li></ul></li><li><a href="#concurrency-and-conflict-resolution">Concurrency and Conflict Resolution</a></li><li><a href="#epochs-and-invariants">Epochs and Invariants</a></li><li><a href="#summary-from-math-to-provable-practices">Summary: From Math to Provable Practices</a><ul><li><a href="#calculus-quick-ref">Calculus Quick-Ref</a></li></ul></li></ul><p><a id="chapter-9-the-gatos-morphology-calculus"></a></p><p>The guarantees of determinism, provability, and composability in GATOS are not just design goals; they are the result of a formal mathematical framework. This framework, the <strong>GATOS Morphology Calculus</strong>, provides the theoretical underpinnings for the entire system. This chapter introduces the core concepts of this calculus, linking the abstract mathematics to the concrete features you use every day.</p><p>The motto of the calculus is simple: <em>Each commit folds the surface into a new, deterministic shape.</em></p><h2 id="core-objects" tabindex="-1">Core Objects <a class="header-anchor" href="#core-objects" aria-label="Permalink to &quot;Core Objects&quot;">​</a></h2><p><a id="core-objects"></a> The calculus is built on a few fundamental objects:</p><ol><li><p><strong>Ledger DAG:</strong> The event history of a GATOS repository is a finite Directed Acyclic Graph (DAG), where <strong>nodes</strong> are events (commits) and <strong>edges</strong> are the parent links between them. This DAG induces a partial order on all events, representing causality.</p></li><li><p><strong>Policy:</strong> A <strong>policy</strong> is an immutable set of rules (e.g., quorums, capabilities, RLS rules) that acts as a parameter for any computation.</p></li><li><p><strong>Shape:</strong> A <strong>shape</strong> is the canonical, serialized form of a system&#39;s state. It is a hashable representation of the &quot;shape of the world&quot; at a given moment.</p></li><li><p><strong>Fold Functor:</strong> A <strong>fold</strong> is a mathematical function (specifically, a <strong>functor</strong>) that transforms the event history into a shape. It is parameterized by a policy, written as $F_P$. This is implemented by the <strong>Echo</strong> engine, which relies on local, confluent rewrite rules (<strong>Echo/DPO</strong> with critical-pair checks).</p><p><code>Fold = F(event_history, policy) -&gt; shape</code></p></li></ol><h2 id="key-theorems-and-their-payoffs" tabindex="-1">Key Theorems and Their Payoffs <a class="header-anchor" href="#key-theorems-and-their-payoffs" aria-label="Permalink to &quot;Key Theorems and Their Payoffs&quot;">​</a></h2><p><a id="key-theorems-and-their-payoffs"></a> The Morphology Calculus is defined by a series of theorems that translate directly into powerful system features.</p><h3 id="theorem-1-deterministic-shape" tabindex="-1">Theorem 1: Deterministic Shape <a class="header-anchor" href="#theorem-1-deterministic-shape" aria-label="Permalink to &quot;Theorem 1: Deterministic Shape&quot;">​</a></h3><p><a id="theorem-1-deterministic-shape"></a></p><blockquote><p>For a fixed policy, any two equivalent event sequences (i.e., containing the same events in the same causal order) will always fold to the exact same shape. Note the dependency on the effective <code>policy_version</code>/<code>policy_root</code>.</p></blockquote><p><strong>Feature Payoff:</strong> This is the foundation of all determinism in GATOS. It guarantees <strong>reproducible state</strong>. If you have the same journal and the same policy, you are guaranteed to compute the same state root hash. This enables verifiable caching, state synchronization, and perfect replay.</p><h3 id="theorem-2-localization-incrementality" tabindex="-1">Theorem 2: Localization &amp; Incrementality <a class="header-anchor" href="#theorem-2-localization-incrementality" aria-label="Permalink to &quot;Theorem 2: Localization &amp; Incrementality&quot;">​</a></h3><p><a id="theorem-2-localization--incrementality"></a><a id="theorem-2-localization-incrementality"></a></p><blockquote><p>If the event history can be partitioned into independent regions (with no read/write overlap per policy), then the fold of the whole history is equivalent to the composition of the folds of each partition.</p></blockquote><p><strong>Feature Payoff:</strong> This enables <strong>partial and lazy folds</strong>. The system doesn&#39;t need to recompute the entire world state for every small change. It only needs to re-fold the partitions affected by new events, dramatically improving performance. This is what justifies the Index &amp; Cache plane. This theorem relies on the concept of <strong>Footprints</strong> and an <strong>Independence Predicate</strong> to define disjoint regions.</p><h3 id="theorem-3-safe-policy-migration" tabindex="-1">Theorem 3: Safe Policy Migration <a class="header-anchor" href="#theorem-3-safe-policy-migration" aria-label="Permalink to &quot;Theorem 3: Safe Policy Migration&quot;">​</a></h3><p><a id="theorem-3-safe-policy-migration"></a></p><blockquote><p>A policy change can be modeled as a <strong>natural transformation</strong> $\\eta: F_P \\Rightarrow F_Q$ between two fold functors. This transformation provides a safe, verifiable way to migrate from a state computed under an old policy to a state computed under a new one.</p></blockquote><figure><img src="'+i+'" alt="diagram 1" loading="lazy"></figure><p><strong>Feature Payoff:</strong> This allows for <strong>governance-safe upgrades</strong>. You can change quorums, validation rules, or capabilities without corrupting existing state, because the migration path is mathematically defined and proven to be consistent.</p><h3 id="theorem-4-mind-meld-as-a-pushout" tabindex="-1">Theorem 4: Mind-Meld as a Pushout <a class="header-anchor" href="#theorem-4-mind-meld-as-a-pushout" aria-label="Permalink to &quot;Theorem 4: Mind-Meld as a Pushout&quot;">​</a></h3><p><a id="theorem-4-mind-meld-as-a-pushout"></a></p><blockquote><p>Two independent GATOS repositories (with no shared history) can be deterministically merged via a <strong>pushout</strong>, a concept from category theory. The merge is guided by a schema that describes the correspondences between the two systems.</p></blockquote><figure><img src="'+s+'" alt="diagram 2" loading="lazy"></figure><p><strong>Feature Payoff:</strong> This enables the <strong>&quot;Mind-Meld&quot;</strong>—a deterministic, conflict-free merge of state between different repositories. This is the foundation for federation and cross-repo collaboration. The process also produces a <code>Proof-of-Meld</code>, a lightweight, attestable certificate of the merge operation. This theorem is a direct consequence of the <strong>Concurrency Theorems</strong> which state that independent DPO squares compose along disjoint sums, leading to isomorphic results regardless of execution order.</p><h3 id="further-theorems" tabindex="-1">Further Theorems <a class="header-anchor" href="#further-theorems" aria-label="Permalink to &quot;Further Theorems&quot;">​</a></h3><p><a id="further-theorems"></a> The calculus extends to other planes, modeling the <strong>Job Plane</strong> as a <strong>symmetric monoidal category</strong> (guaranteeing parallel soundness) and the <strong>Ledger&#39;s consensus governance</strong> as a <strong>2-category</strong> (providing algebraic idempotence for approvals and grants). It even provides a model for <strong>hierarchical compaction</strong> (&quot;folds-of-folds&quot;) using <strong>operads</strong>, which justifies the safe creation of summary epochs.</p><h2 id="concurrency-and-conflict-resolution" tabindex="-1">Concurrency and Conflict Resolution <a class="header-anchor" href="#concurrency-and-conflict-resolution" aria-label="Permalink to &quot;Concurrency and Conflict Resolution&quot;">​</a></h2><p><a id="concurrency-and-conflict-resolution"></a> The operational semantics of GATOS&#39;s concurrent rewriting are critical for maintaining determinism.</p><ul><li><strong>Footprints:</strong> Each rewrite rule precisely defines its read/write sets on nodes, edges, and <strong>Ports</strong> (boundary interfaces).</li><li><strong>Independence Predicate:</strong> Two rewrites are independent if their read/write sets over nodes and ports are disjoint (no overlap) and their <code>factor_mask</code>s do not overlap.</li><li><strong>Concurrency Theorems:</strong> If rewrites are independent, they commute up to isomorphism. This means they can be executed in any order, or in parallel, yielding the same result.</li><li><strong>Conflict Resolution Policies:</strong> When conflicts are detected (independence violation), GATOS rules define how to resolve them: <code>ABORT</code>, <code>RETRY</code>, <code>JOIN</code> (applying a precomputed join), or <code>USER_RESOLVE</code> (invoking a domain callback).</li></ul><h2 id="epochs-and-invariants" tabindex="-1">Epochs and Invariants <a class="header-anchor" href="#epochs-and-invariants" aria-label="Permalink to &quot;Epochs and Invariants&quot;">​</a></h2><p><a id="epochs-and-invariants"></a> GATOS uses <strong>Epochs</strong> to manage the coherence of its state. Epochs are monotonically increasing counters (<code>epoch_att</code> for attachments, <code>epoch_skel</code> for skeleton) that ensure readers always observe a consistent state.</p><ul><li><strong>Snapshot Isolation:</strong> Readers are bound to specific epoch counters and never witness a partially updated or &quot;torn&quot; state.</li><li><strong>Atomicity:</strong> A committed rewrite either appears entirely in the next epoch(s) or not at all.</li><li><strong>Epoch Flip:</strong> Epochs only advance after all changes are published, ensuring a coherent world-rollover for readers.</li></ul><p>These invariants are crucial for maintaining the integrity of the GATOS operating surface.</p><h2 id="summary-from-math-to-provable-practices" tabindex="-1">Summary: From Math to Provable Practices <a class="header-anchor" href="#summary-from-math-to-provable-practices" aria-label="Permalink to &quot;Summary: From Math to Provable Practices&quot;">​</a></h2><p><a id="summary-from-math-to-provable-practices"></a> The GATOS Morphology Calculus is not merely an academic exercise. It is a practical engineering playbook. By building the system on a foundation of provable mathematics, GATOS moves beyond &quot;best practices&quot; to <strong>provable practices</strong>.</p><p>Each theorem corresponds directly to a feature that provides a concrete benefit:</p><ul><li><strong>Determinism</strong> gives you reproducible state.</li><li><strong>Localization</strong> gives you fast, incremental updates.</li><li><strong>Natural Transformations</strong> give you safe policy migrations.</li><li><strong>Pushouts</strong> give you deterministic cross-repo merges.</li></ul><p>This is how GATOS delivers on its promise of a system that is not just powerful, but also trustworthy, auditable, and correct by construction.</p><h3 id="calculus-quick-ref" tabindex="-1">Calculus Quick-Ref <a class="header-anchor" href="#calculus-quick-ref" aria-label="Permalink to &quot;Calculus Quick-Ref&quot;">​</a></h3><p><a id="calculus-quick-ref"></a><a id="calculus-quickref"></a></p><ul><li>Fold functor <code>F_P</code>: Maps histories to shapes under policy <code>P</code>.</li><li>Natural transformation <code>η: F_P ⇒ F_Q</code>: Safe migration from policy <code>P</code> to <code>Q</code>.</li><li>Pushout: Canonical construction to merge two shapes along a schema of correspondences.</li></ul>',46)])])}const f=o(n,[["render",c]]);export{g as __pageData,f as default};
