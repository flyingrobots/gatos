import{_ as i,c as a,o,a3 as t}from"./chunks/framework.BXNB9gP7.js";const s="/gatos/pr-preview/pr-64/assets/docs_decisions_ADR-0002_DECISION__a21cc79f92__mermaid_1.BJy0tAgA.svg",n="/gatos/pr-preview/pr-64/assets/docs_decisions_ADR-0002_DECISION__a21cc79f92__mermaid_2.CFzuiiuy.svg",m=JSON.parse('{"title":"ADR-0002: Distributed Compute via a Job Plane","description":"","frontmatter":{"Status":"Accepted","Date":"2025-11-08T00:00:00.000Z","ADR":"ADR-0002","Authors":["flyingrobots"],"Requires":["ADR-0001"],"Related":["ADR-0003"],"Tags":["Job Plane","Compute","PoE"],"Schemas":["schemas/v1/job/job_manifest.schema.json","schemas/v1/job/proof_of_execution_envelope.schema.json"],"Supersedes":[],"Superseded-By":[]},"headers":[],"relativePath":"decisions/ADR-0002/DECISION.md","filePath":"decisions/ADR-0002/DECISION.md","lastUpdated":1763125191000}'),l={name:"decisions/ADR-0002/DECISION.md"};function r(c,e,d,h,p,u){return o(),a("div",{"data-pagefind-body":!0},[...e[0]||(e[0]=[t(`<h1 id="adr-0002-distributed-compute-via-a-job-plane" tabindex="-1">ADR-0002: Distributed Compute via a Job Plane <a class="header-anchor" href="#adr-0002-distributed-compute-via-a-job-plane" aria-label="Permalink to &quot;ADR-0002: Distributed Compute via a Job Plane&quot;">​</a></h1><p><a id="adr-0002-distributed-compute-via-a-job-plane"></a></p><p><a id="adr-0002-distributed-compute-via-a-job-plane"></a></p><ul><li><a href="#scope">Scope</a></li><li><a href="#rationale">Rationale</a></li><li><a href="#decision">Decision</a><ul><li><a href="#canonical-job-identifier">Canonical Job Identifier</a></li><li><a href="#job-manifest-schema-authoritative-and-canonicalization">Job Manifest Schema (Authoritative and Canonicalization)</a></li><li><a href="#atomic-claim-protocol-cas">Atomic Claim Protocol (CAS)</a></li><li><a href="#trailer-encoding-result-commit">Trailer Encoding (Result Commit)</a></li></ul></li><li><a href="#diagrams">Diagrams</a><ul><li><a href="#job-lifecycle">Job Lifecycle</a></li><li><a href="#job-discovery-and-execution-flow">Job Discovery and Execution Flow</a></li></ul></li><li><a href="#consequences">Consequences</a><ul><li><a href="#pros">Pros</a></li><li><a href="#cons">Cons</a></li></ul></li><li><a href="#alternatives-considered">Alternatives Considered</a></li><li><a href="#terminology-and-references">Terminology and References</a></li></ul><p><a id="adr-0002-distributed-compute-via-a-job-plane"></a></p><ul><li><strong>Status:</strong> Accepted</li><li><strong>Date:</strong> 2025-11-08</li></ul><h2 id="scope" tabindex="-1">Scope <a class="header-anchor" href="#scope" aria-label="Permalink to &quot;Scope&quot;">​</a></h2><p><a id="scope"></a></p><p><a id="scope"></a> This ADR defines a system within GATOS for scheduling, executing, and recording the results of distributed, asynchronous jobs. This decision introduces the <strong>Job Plane</strong> and its associated Git namespaces and protocols.</p><h2 id="rationale" tabindex="-1">Rationale <a class="header-anchor" href="#rationale" aria-label="Permalink to &quot;Rationale&quot;">​</a></h2><p><a id="rationale"></a></p><p><a id="rationale"></a><strong>Problem:</strong> GATOS can track and govern state, but cannot currently orchestrate or react to state changes with computation.</p><p><strong>Context:</strong> To fulfill the vision of “Git as an Operating Surface”, computation must be a native citizen. Commits as “speech-acts” (the original metaphor) become literal when a commit can trigger a verifiable job.</p><h2 id="decision" tabindex="-1">Decision <a class="header-anchor" href="#decision" aria-label="Permalink to &quot;Decision&quot;">​</a></h2><p><a id="decision"></a></p><p><a id="decision"></a></p><ol><li>A new <strong>Job Plane</strong> <strong>MUST</strong> be introduced to the GATOS architecture.</li><li>The <code>refs/gatos/jobs/</code> namespace is reserved for this plane.</li><li>When a <strong>Job</strong> commit is created, the <strong>Ledger Service</strong> (e.g., <code>gatosd</code>) <strong>MUST</strong> publish a corresponding message to a topic on the Message Plane (e.g., <code>gatos/jobs/pending</code>) for discovery by workers. Publication is an automatic system behavior on commit acceptance.</li><li>The job lifecycle <strong>MUST</strong> be represented entirely through Git objects: <ul><li><strong>Job:</strong> A commit whose tree contains a <code>job.yaml</code> manifest. The manifest <strong>MUST</strong> include <code>command</code>, <code>args</code>, and <code>timeout</code> fields, and <strong>SHOULD</strong> include <code>policy_root</code> and an <code>inputs</code> array for deterministic attestation. See schema: <a href="../../../schemas/v1/job/job_manifest.schema.json"><code>schemas/v1/job/job_manifest.schema.json</code></a>.</li><li><strong>Claim:</strong> A ref under <code>refs/gatos/jobs/&lt;job-id&gt;/claims/&lt;worker-id&gt;</code>. This ref <strong>MUST</strong> be created atomically (compare-and-swap) to prevent race conditions.</li><li><strong>Result:</strong> A commit referencing the original job commit, containing output artifacts (as pointers) and a <code>Proof-Of-Execution</code>.</li></ul></li><li>The <strong>Proof-Of-Execution</strong> <strong>MUST</strong> sign the job’s <code>content_id</code> and <strong>MAY</strong> include an attestation envelope with hashes of the runner binary and environment. See envelope schema: <a href="../../../schemas/v1/job/proof_of_execution_envelope.schema.json"><code>schemas/v1/job/proof_of_execution_envelope.schema.json</code></a>.</li><li>Each <code>Result</code> commit <strong>MUST</strong> include trailers for discoverability: <ul><li><code>Job-Id: blake3:&lt;hex&gt;</code></li><li><code>Proof-Of-Execution: blake3:&lt;hex&gt;</code></li><li><code>Worker-Id: ed25519:&lt;base64|hex&gt;</code></li><li><code>Attest-Program: &lt;hash-of-runner-binary&gt;</code> (optional)</li><li><code>Attest-Sig: &lt;signature&gt;</code> (optional)</li></ul></li></ol><h3 id="canonical-job-identifier" tabindex="-1">Canonical Job Identifier <a class="header-anchor" href="#canonical-job-identifier" aria-label="Permalink to &quot;Canonical Job Identifier&quot;">​</a></h3><p><a id="canonical-job-identifier"></a></p><p><a id="canonical-job-identifier"></a> The canonical job identifier is the job’s <code>content_id</code> (the BLAKE3 hash of the canonical serialization of the unsigned job core). All protocol elements that refer to a job MUST use this <code>job-id</code>.</p><ul><li>Claim refs MUST be named <code>refs/gatos/jobs/&lt;job-id&gt;/claims/&lt;worker-id&gt;</code>.</li><li>Result trailers MUST use <code>Job-Id: blake3:&lt;hex&gt;</code> corresponding to the same <code>job-id</code>.</li></ul><p>ULIDs MAY be used as human-friendly aliases in messages (for deduplication, sorting, and UX). When present, the ULID MUST also be recorded in the job manifest. Workers MUST resolve ULIDs to the canonical <code>job-id</code> by reading the job commit and computing its <code>content_id</code>. ULIDs MUST NOT be used as ref keys for claims or results.</p><h3 id="job-manifest-schema-authoritative-and-canonicalization" tabindex="-1">Job Manifest Schema (Authoritative and Canonicalization) <a class="header-anchor" href="#job-manifest-schema-authoritative-and-canonicalization" aria-label="Permalink to &quot;Job Manifest Schema (Authoritative and Canonicalization)&quot;">​</a></h3><p><a id="job-manifest-schema-authoritative-and-canonicalization"></a></p><p><a id="job-manifest-schema-authoritative-and-canonicalization"></a> The job manifest is stored as <code>job.yaml</code> but the authoritative form for hashing and <code>content_id</code> computation is Canonical JSON.</p><ul><li>Serialization for hashing: Canonical JSON (UTF-8, sorted keys, no insignificant whitespace, lowercase hex where applicable).</li><li>Conversion: YAML authorship is allowed; before hashing, <code>job.yaml</code> MUST be converted to JSON with field order ignored and then canonicalized.</li><li>Required fields and types: <ul><li><code>command: array&lt;string&gt;</code> — executable and arguments (e.g., <code>[&quot;/usr/bin/env&quot;, &quot;bash&quot;, &quot;-lc&quot;]</code>).</li><li><code>args: array&lt;string&gt;</code> — additional arguments appended to <code>command</code> (may be empty). If omitted, treated as <code>[]</code>.</li><li><code>timeout: integer</code> — seconds (non-negative). Implementations MAY also accept ISO-8601 duration strings at authoring time but MUST normalize to integer seconds in Canonical JSON.</li></ul></li><li>Optional fields: <ul><li><code>env: object</code> — map&lt;string,string&gt;; keys unique; values UTF-8 strings.</li><li><code>cwd: string</code> — working directory.</li><li><code>inputs: array&lt;object&gt;</code> — opaque pointers or references to inputs (e.g., <code>{ &quot;kind&quot;:&quot;blobptr&quot;, &quot;algo&quot;:&quot;blake3&quot;, &quot;hash&quot;:&quot;&lt;hex&gt;&quot;, &quot;size&quot;:123 }</code>).</li><li><code>policy_root: string</code> — <code>sha256:&lt;hex&gt;</code> of policy bundle used.</li><li><code>ulid: string</code> — human-friendly identifier; not used for hashing.</li></ul></li></ul><p>Canonicalization rules for <code>content_id</code>:</p><ol><li>Build a JSON object with the fields above, omitting absent optional fields.</li><li>Sort keys lexicographically; arrays preserve order.</li><li>Encode as UTF-8 without insignificant whitespace; booleans and numbers use standard JSON encoding; all hex encodings are lowercase.</li><li>Compute <code>content_id = blake3(canonical_bytes)</code>.</li></ol><p>Examples</p><p>Authoring YAML:</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">command</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/usr/bin/env&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;bash&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-lc&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;echo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">timeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">env</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">GREETING</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><p>Canonical JSON used for hashing:</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;args&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;echo&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;command&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/usr/bin/env&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;bash&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-lc&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;env&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;GREETING&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;timeout&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="atomic-claim-protocol-cas" tabindex="-1">Atomic Claim Protocol (CAS) <a class="header-anchor" href="#atomic-claim-protocol-cas" aria-label="Permalink to &quot;Atomic Claim Protocol (CAS)&quot;">​</a></h3><p><a id="atomic-claim-protocol-cas"></a></p><p><a id="atomic-claim-protocol-cas"></a> Claim creation MUST use Git’s reference update protocol with an expected old object id:</p><ul><li>To create <code>refs/gatos/jobs/&lt;job-id&gt;/claims/&lt;worker-id&gt;</code>, the client MUST request an atomic update with expected old = <code>0000000000000000000000000000000000000000</code> (zero OID).</li><li>If the reference already exists or the expected old does not match, the server MUST reject the update with a deterministic conflict error. The worker MUST treat this as a lost race and enter the retry/backoff loop.</li><li>Deployments MUST designate a single authoritative push endpoint (leader) for claim creation to guarantee atomicity across replicas. Retrying against non-authoritative replicas MUST converge via eventual consistency.</li><li>Workers SHOULD use exponential backoff with jitter on CAS failures.</li></ul><h3 id="trailer-encoding-result-commit" tabindex="-1">Trailer Encoding (Result Commit) <a class="header-anchor" href="#trailer-encoding-result-commit" aria-label="Permalink to &quot;Trailer Encoding (Result Commit)&quot;">​</a></h3><p><a id="trailer-encoding-result-commit"></a></p><p><a id="trailer-encoding-result-commit"></a> All trailers MUST use canonical, prefixed encodings:</p><ul><li><code>Job-Id: blake3:&lt;hex&gt;</code> — lowercase hex digest of the job <code>content_id</code>.</li><li><code>Proof-Of-Execution: blake3:&lt;hex&gt;</code> — lowercase hex digest of the PoE envelope.</li><li><code>Worker-Id: ed25519:&lt;base64|hex&gt;</code> — worker public key identifier (algorithm prefix required).</li><li><code>Attest-Program: blake3:&lt;hex&gt;</code> — hash of runner binary or WASM module (RECOMMENDED).</li><li><code>Attest-Sig: ed25519:&lt;base64|hex&gt;</code> — signature over attestation envelope (OPTIONAL).</li></ul><p>Encodings MUST be lowercase hex for BLAKE3 digests; key/signature encodings MUST declare algorithm via prefix and use a standard encoding (hex or base64) documented by the implementation.</p><h2 id="diagrams" tabindex="-1">Diagrams <a class="header-anchor" href="#diagrams" aria-label="Permalink to &quot;Diagrams&quot;">​</a></h2><p><a id="diagrams"></a></p><p><a id="diagrams"></a></p><h3 id="job-lifecycle" tabindex="-1">Job Lifecycle <a class="header-anchor" href="#job-lifecycle" aria-label="Permalink to &quot;Job Lifecycle&quot;">​</a></h3><p><a id="job-lifecycle"></a></p><p><a id="job-lifecycle"></a> This diagram shows the standard lifecycle states for a job as it moves through the system.</p><figure><img src="`+s+'" alt="diagram 1" loading="lazy"></figure><h3 id="job-discovery-and-execution-flow" tabindex="-1">Job Discovery and Execution Flow <a class="header-anchor" href="#job-discovery-and-execution-flow" aria-label="Permalink to &quot;Job Discovery and Execution Flow&quot;">​</a></h3><p><a id="job-discovery-and-execution-flow"></a></p><p><a id="job-discovery-and-execution-flow"></a> This sequence shows how the different GATOS planes interact to schedule and execute a job.</p><figure><img src="'+n+'" alt="diagram 2" loading="lazy"></figure><h2 id="consequences" tabindex="-1">Consequences <a class="header-anchor" href="#consequences" aria-label="Permalink to &quot;Consequences&quot;">​</a></h2><p><a id="consequences"></a></p><p><a id="consequences"></a></p><h3 id="pros" tabindex="-1">Pros <a class="header-anchor" href="#pros" aria-label="Permalink to &quot;Pros&quot;">​</a></h3><p><a id="pros"></a></p><p><a id="pros"></a></p><ul><li>Makes GATOS an active system capable of executing work deterministically.</li><li>Enables fully auditable automation workflows (“on state change, run test job”).</li><li>Preserves Git’s distributed, offline semantics for job distribution and result collection.</li></ul><h3 id="cons" tabindex="-1">Cons <a class="header-anchor" href="#cons" aria-label="Permalink to &quot;Cons&quot;">​</a></h3><p><a id="cons"></a></p><p><a id="cons"></a></p><ul><li>Increases complexity; requires new runner/worker components to be built.</li><li>Adds storage overhead for job logs and artifacts.</li></ul><h2 id="alternatives-considered" tabindex="-1">Alternatives Considered <a class="header-anchor" href="#alternatives-considered" aria-label="Permalink to &quot;Alternatives Considered&quot;">​</a></h2><p><a id="alternatives-considered"></a></p><p><a id="alternatives-considered"></a></p><ol><li><strong>External CI/CD Systems</strong> — Rejected: breaks the self-contained, Git-native model.</li><li><strong>Webhooks</strong> — Rejected: less reliable and less auditable than Git-tracked claims/results.</li></ol><h2 id="terminology-and-references" tabindex="-1">Terminology and References <a class="header-anchor" href="#terminology-and-references" aria-label="Permalink to &quot;Terminology and References&quot;">​</a></h2><p><a id="terminology-and-references"></a></p><p><a id="terminology-and-references"></a></p><ul><li><code>content_id</code>: The BLAKE3 hash of the canonical serialization of the unsigned job core. This mirrors the definition used for commits in ADR-0001 and applies here to the job manifest’s canonical form. See ADR-0001 for canonical serialization rules and the <code>CommitCore</code> pattern.</li><li><code>unsigned job core</code>: The canonical, serialized job content used for hashing and signatures; derived from the job manifest (e.g., <code>job.yaml</code>) and fixed fields, excluding any signatures, claims, or result artifacts. This parallels ADR-0001’s &quot;unsigned commit core&quot; concept.</li></ul>',72)])])}const b=i(l,[["render",r]]);export{m as __pageData,b as default};
