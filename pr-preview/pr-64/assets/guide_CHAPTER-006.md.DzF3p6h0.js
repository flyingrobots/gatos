import{_ as s,c as t,o as a,a3 as i}from"./chunks/framework.BXNB9gP7.js";const o="/gatos/pr-preview/pr-64/assets/docs_guide_CHAPTER-006__d8205dc3b9__mermaid_1.DGyg0PYZ.svg",g=JSON.parse('{"title":"Chapter 6: The Message & Job Planes: Distributed Workflows","description":"","frontmatter":{},"headers":[],"relativePath":"guide/CHAPTER-006.md","filePath":"guide/CHAPTER-006.md","lastUpdated":1763134160000}'),n={name:"guide/CHAPTER-006.md"};function r(l,e,h,d,c,p){return a(),t("div",{"data-pagefind-body":!0},[...e[0]||(e[0]=[i('<h1 id="chapter-6-the-message-job-planes-distributed-workflows" tabindex="-1">Chapter 6: The Message &amp; Job Planes: Distributed Workflows <a class="header-anchor" href="#chapter-6-the-message-job-planes-distributed-workflows" aria-label="Permalink to &quot;Chapter 6: The Message &amp; Job Planes: Distributed Workflows&quot;">​</a></h1><p><a id="chapter-6-the-message-job-planes-distributed-workflows"></a></p><ul><li><a href="#the-message-plane-a-commit-backed-bus">The Message Plane: A Commit-Backed Bus</a><ul><li><a href="#how-it-works">How It Works</a></li></ul></li><li><a href="#the-job-plane-verifiable-computation">The Job Plane: Verifiable Computation</a><ul><li><a href="#the-job-lifecycle">The Job Lifecycle</a></li><li><a href="#proof-of-execution-poe">Proof-of-Execution (PoE)</a></li><li><a href="#bus-retention-compaction-guidance">Bus Retention &amp; Compaction Guidance</a></li></ul></li><li><a href="#summary">Summary</a></li></ul><p><a id="chapter-6-the-message-job-planes-distributed-workflows"></a></p><p>While the Ledger, State, and Policy planes provide the core foundation for a verifiable system, the <strong>Message Plane</strong> and <strong>Job Plane</strong> bring it to life. They provide the mechanisms for communication and asynchronous work, enabling GATOS to function as a true distributed <strong>operating surface</strong>.</p><h2 id="the-message-plane-a-commit-backed-bus" tabindex="-1">The Message Plane: A Commit-Backed Bus <a class="header-anchor" href="#the-message-plane-a-commit-backed-bus" aria-label="Permalink to &quot;The Message Plane: A Commit-Backed Bus&quot;">​</a></h2><p><a id="the-message-plane-a-commit-backed-bus"></a> The Message Plane, managed by the <strong><code>gatos-mind</code></strong> crate, provides a reliable, asynchronous publish/subscribe message bus built directly on Git. It serves as the central nervous system for GATOS.</p><h3 id="how-it-works" tabindex="-1">How It Works <a class="header-anchor" href="#how-it-works" aria-label="Permalink to &quot;How It Works&quot;">​</a></h3><p><a id="how-it-works"></a></p><ol><li><strong>Topics as Refs:</strong> Each message topic is a Git ref under the <code>refs/gatos/mbus/&lt;topic&gt;/&lt;shard&gt;</code> namespace.</li><li><strong>Messages as Commits:</strong> When a publisher sends a message to a topic, <code>gatos-mind</code> creates a new commit on the topic ref. The message payload is stored in the commit.</li><li><strong>Consumption:</strong> Subscribers <code>git fetch</code> the topic refs to discover new messages.</li><li><strong>Acknowledgements:</strong> Delivery is <strong>at-least-once</strong>. Use idempotency keys (the message <code>ULID</code>) and dedupe on read. Consumers write an <code>ack</code> commit to a corresponding <code>refs/gatos/mbus-ack/</code> ref; the system can then observe that a message has been processed by a quorum before considering it “done.”</li></ol><p>This Git-native approach provides a message bus that is:</p><ul><li><strong>Durable:</strong> Messages are as durable as your Git repository.</li><li><strong>Auditable:</strong> The entire history of communication is preserved.</li><li><strong>Decentralized:</strong> Publishers and subscribers only need access to the Git remote.</li></ul><h2 id="the-job-plane-verifiable-computation" tabindex="-1">The Job Plane: Verifiable Computation <a class="header-anchor" href="#the-job-plane-verifiable-computation" aria-label="Permalink to &quot;The Job Plane: Verifiable Computation&quot;">​</a></h2><p><a id="the-job-plane-verifiable-computation"></a> The Job Plane, managed by the <strong><code>gatos-compute</code></strong> crate, builds on the other planes to create a system for scheduling, executing, and recording the results of distributed, asynchronous work.</p><h3 id="the-job-lifecycle" tabindex="-1">The Job Lifecycle <a class="header-anchor" href="#the-job-lifecycle" aria-label="Permalink to &quot;The Job Lifecycle&quot;">​</a></h3><p><a id="the-job-lifecycle"></a> The entire lifecycle of a job is represented as a series of events in the GATOS ledger. This diagram shows the flow from a client&#39;s request to the final result being recorded.</p><figure><img src="'+o+`" alt="diagram 1" loading="lazy"></figure><ol><li><strong>Scheduling:</strong> A job is scheduled by writing a <code>jobs.enqueue</code> event to the Ledger Plane. This event contains a manifest describing the work to be done (e.g., a command to run, input data).</li><li><strong>Discovery:</strong> A message is published to a topic on the Message Plane (e.g., <code>gatos.jobs.pending</code>), announcing the new job.</li><li><strong>Claiming:</strong> A <code>gatos-compute</code> worker, subscribed to the topic, discovers the job. It then performs an atomic compare-and-swap on a single lock ref <code>refs/gatos/jobs/&lt;job-id&gt;/claim</code> using <code>git update-ref &lt;old=000..0&gt; &lt;new-claim-oid&gt;</code>. The winner (who observed the zero OID) writes its <code>worker_id</code> into the claim object, preventing other workers from executing it.</li><li><strong>Execution:</strong> The worker executes the job&#39;s <code>command</code> in a sandboxed environment.</li><li><strong>Result:</strong> Upon completion, the worker creates a <code>jobs.result</code> event and commits it to the ledger. This event includes the job&#39;s output, exit status, and, crucially, a <strong>Proof-of-Execution (PoE)</strong>.</li></ol><h3 id="proof-of-execution-poe" tabindex="-1">Proof-of-Execution (PoE) <a class="header-anchor" href="#proof-of-execution-poe" aria-label="Permalink to &quot;Proof-of-Execution (PoE)&quot;">​</a></h3><p><a id="proof-of-execution-poe"></a> The <strong>PoE</strong> is a signed attestation that provides verifiable proof that a specific worker executed a specific job. It proves provenance/authenticity (who ran what, where, on which inputs), not correctness. A specimen canonical envelope:</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;job_id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;blake3:&lt;hex&gt;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;worker_id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ed25519:&lt;pubkey&gt;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;worker_env&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">&quot;container_digest&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sha256:&lt;hex&gt;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;input_refs&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;blake3:&lt;hex&gt;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;cidv1:...&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;output_hash&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;blake3:&lt;hex&gt;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;sig_alg&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ed25519&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;sig&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ed25519:&lt;base64&gt;&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Storage: <code>refs/gatos/jobs/&lt;job-id&gt;/result</code> (commit whose tree contains the result manifest and PoE). Commit trailers include <code>Job-Id</code>, <code>Proof-Of-Execution</code>, and <code>Worker-Id</code>.</p><h3 id="bus-retention-compaction-guidance" tabindex="-1">Bus Retention &amp; Compaction Guidance <a class="header-anchor" href="#bus-retention-compaction-guidance" aria-label="Permalink to &quot;Bus Retention &amp; Compaction Guidance&quot;">​</a></h3><p><a id="bus-retention-compaction-guidance"></a></p><ul><li>Segment topics: <code>refs/gatos/mbus/&lt;topic&gt;/&lt;yyyy&gt;/&lt;mm&gt;/&lt;dd&gt;/&lt;segment-ulid&gt;</code> (or numeric <code>0001</code>, <code>0002</code>, …) to bound ref sizes.</li><li>Rotation thresholds (defaults): rotate at 100k messages or ~192 MB per segment (whichever comes first).</li><li>TTL: retain segments for 30 days, then prune; write a summary commit (counts, Merkle root, last offsets) when pruning to preserve verifiability.</li><li>Offsets: snapshot consumer offsets; prune only segments older than the minimum acknowledged offset across active consumers.</li><li>Git optimization: enable <code>fetch.writeCommitGraph=true</code>, <code>repack.writeBitmaps=true</code>; consider partial clone/promisor remotes for <code>refs/gatos/mbus/*</code> on busy installations.</li></ul><h2 id="summary" tabindex="-1">Summary <a class="header-anchor" href="#summary" aria-label="Permalink to &quot;Summary&quot;">​</a></h2><p><a id="summary"></a> The Message and Job planes are what make GATOS a dynamic, living system. <code>gatos-mind</code> provides the nervous system, allowing for reliable, auditable communication. <code>gatos-compute</code> provides the motor function, enabling the system to perform work in a distributed and verifiable way.</p><p>Together, they transform the GATOS repository from a passive record of history into an active, programmable &quot;Operating Surface&quot; that can orchestrate complex, distributed workflows with an unprecedented level of trust and transparency.</p>`,28)])])}const m=s(n,[["render",r]]);export{g as __pageData,m as default};
