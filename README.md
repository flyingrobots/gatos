# ðŸˆâ€â¬› **GATOS**

> [!WARNING]
> **GATOS** is the evolution of my earlier work ([`git-mind`](https://github.com/neuroglyph/git-mind), [Echo](https://github.com/flyingrobots/echo), [Ledger Kernel](https://github.com/flyingrobots/ledger-kernel), etc.) into a single, unified system. 
> 
> Yessir, this here repo is ***brand spankin' new***, and it sort of represents the _confluence*_ of many of my recent projects into one **pretty good ideaâ„¢**. Working on MVP ASAP. Star the repo, follow along, and let's _git_ it!  
> 
> _- flyingrobots_
> 
> _* a little category theory joke... Eh, maybe you had to be there..._

```bash

8""""8 8""""8 ""8"" 8"""88 8""""8 
8    " 8    8   8   8    8 8      
8e     8eeee8   8e  8    8 8eeeee 
88  ee 88   8   88  8    8     88 
88   8 88   8   88  8    8 e   88 
88eee8 88   8   88  8eeee8 8eee88 
 
  Git As The Operating Surfaceâ„¢  
```

```c
â”â”â•¸â•»â•ºâ”³â•¸                     
â”ƒâ•ºâ”“â”ƒ â”ƒ                      
â”—â”â”›â•¹ â•¹                      
â”â”â”“â”â”â”“                      
â”£â”â”«â”—â”â”“                      
â•¹ â•¹â”—â”â”›                      
â•ºâ”³â•¸â•» â•»â”â”â•¸                   
 â”ƒ â”£â”â”«â”£â•¸                    
 â•¹ â•¹ â•¹â”—â”â•¸                   
â”â”â”“â”â”â”“â”â”â•¸â”â”â”“â”â”â”“â•ºâ”³â•¸â•»â”â”“â•»â”â”â•¸   
â”ƒ â”ƒâ”£â”â”›â”£â•¸ â”£â”³â”›â”£â”â”« â”ƒ â”ƒâ”ƒâ”—â”«â”ƒâ•ºâ”“   
â”—â”â”›â•¹  â”—â”â•¸â•¹â”—â•¸â•¹ â•¹ â•¹ â•¹â•¹ â•¹â”—â”â”›   
â”â”â”“â•» â•»â”â”â”“â”â”â•¸â”â”â”“â”â”â•¸â”â”â•¸â„¢       
â”—â”â”“â”ƒ â”ƒâ”£â”³â”›â”£â•¸ â”£â”â”«â”ƒ  â”£â•¸        
â”—â”â”›â”—â”â”›â•¹â”—â•¸â•¹  â•¹ â•¹â”—â”â•¸â”—â”â•¸       
```
> _It's **G**it, **A**s **T**he **O**perating **S**urfaceâ„¢._

One part "operating surface".  
One part Git.    
What else is there to say?    
I mean, haha, c'mon, right?.    
The name is _pretty_ descriptive.  

> _"Oh, GATOS? Yes, I've heard that it's like an operating surface and that it's Git. That's right."_

YoU dOnT kNoW wHaT gAtOs Is?! OmG!

Y'all got that "Git-OS" thang?
_It's GATOS!_

**GATOS. It's the Surface that Operates within Git.**

I _git_ it now!

```c
MM'"""""`MM oo   dP                                                            
M' .mmm. `M      88                                                            
M  MMMMMMMM dP d8888P                                                          
M  MMM   `M 88   88                                                            
M. `MMM' .M 88   88                                                            
MM.     .MM dP   dP                                                            
MMMMMMMMMMM                                                                    
                                                                               
MMP"""""""MM                                                                   
M' .mmmm  MM                                                                   
M         `M .d8888b.                                                          
M  MMMMM  MM Y8ooooo.                                                          
M  MMMMM  MM       88                                                          
M  MMMMM  MM `88888P'                                                          
MMMMMMMMMMMM                                                                   
                                                                               
M""""""""M dP                                                                  
Mmmm  mmmM 88                                                                  
MMMM  MMMM 88d888b. .d8888b.                                                   
MMMM  MMMM 88'  `88 88ooood8                                                   
MMMM  MMMM 88    88 88.  ...                                                   
MMMM  MMMM dP    dP `88888P'                                                   
MMMMMMMMMM                                                                     
                                                                               
MMP"""""YMM                                       dP   oo                      
M' .mmm. `M                                       88                           
M  MMMMM  M 88d888b. .d8888b. 88d888b. .d8888b. d8888P dP 88d888b. .d8888b.    
M  MMMMM  M 88'  `88 88ooood8 88'  `88 88'  `88   88   88 88'  `88 88'  `88    
M. `MMM' .M 88.  .88 88.  ... 88       88.  .88   88   88 88    88 88.  .88    
MMb     dMM 88Y888P' `88888P' dP       `88888P8   dP   dP dP    dP `8888P88    
MMMMMMMMMMM 88                                                          .88    
            dP                                                      d8888P     
MP""""""`MM                   .8888b                                           
M  mmmmm..M                   88   "                                           
M.      `YM dP    dP 88d888b. 88aaa  .d8888b. .d8888b. .d8888b.â„¢                
MMMMMMM.  M 88    88 88'  `88 88     88'  `88 88'  `"" 88ooood8                
M. .MMM'  M 88.  .88 88       88     88.  .88 88.  ... 88.  ...                
Mb.     .dM `88888P' dP       dP     `88888P8 `88888P' `88888P'                
MMMMMMMMMMM                                                                    
                                                                               
```

_That's not just any surface! Why, that's an **operating surface**, that's also Git. Neat!_

... You see? That's why they call it "GATOS"...

They say it's the operating surface that _gits_ it! Get it?

Gee, I just can't imagine my life without GATOS, now.

**Finally.** The operating surface that's _Git_.

---

- **Deterministic**
- **Git-native** operating surface for
- **distributed programs**,
- **policies**, and
- **proofs.**

These are just _some_ of the buzzwords that people have been using to describe what computer scientists are calling "GATOS", Git As The Operating Surfaceâ„¢.

"Well, they said it couldn't be done. So, here we are, doing it. And having fun, too!" - flyingrobots, inventor of GATOS.

Ask yourself...

- What if computers shared a public, zero-proof, distributed, deterministic, state space?  
- What if every ref in the Git repo was a process, and every commit represented a snapshot of its state in time?  
- What if policy was code, and it was woven into the very fabric of the repository's history? 
- What if it was **immutable**, **append-only**, **cryptographically-signed**, state? 
- **Offline-first**, **mergeable**, **forkable**, **time-travel-able**?
- What if privacy was **programmable**?
- What if it was **bit-for-bit** deterministic? 
- What if there was such a thing as secure, public, distributed, general purpose computing?
- Without a blockchain?

... and wonder...

- That's the power of the gods.
- That's the power of forever.
- **_That's_** the power of **GATOS**.

> _It's distributed runtime, Baby!_

**GATOS:** _Git As **the** Operating Surfaceâ„¢_

> [!WARNING]
> Exposure to GATOS may include side-effects such as: feeling "badass", becoming curious about Open-Source Software, speaking to the computer, and the sensation that time has elaspsed at an abnormally fast pace. In a controlled study, 1% of participants lost their car keys, but they came back to retrieve them the following day. Please, enjoy GATOS responsibly.

---

## OK, WTF is GATOS?!!

> ***How can a human and an AI collaborate effectively on complex tasks?***

This project is special. Its origin story, a practical problem leading to a profound architectural insight, is the hallmark of truly innovative software.

**GATOS** is not just an abstract specification; it is the concrete answer to the question, *"How can a human and an AI collaborate effectively on complex tasks?"* The entire architecture (the event-sourced ledger, the deterministic state, the policy engine, the JSONL protocol) is purpose-built to enable this new kind of human-computer interaction. It's a tool built not just for getting a job done, but for *thinking and remembering the process of getting it done*.

The potential here is immense, and it extends far beyond the initial [draft-punks](https://github.com/flyingrobots/daft-punks) tool.

### A New Application Backend

**GATOS** is effectively a new kind of serverless, distributed, auditable backend. Any application that needs state management, auditability, and offline capabilities could be built on it. 

Think of a kanban board where every card move is a verifiable commit, or a configuration management system where every change is a signed, auditable event.
      
### The "Operating System" for AI Agents 

> ***An AI agent could use the `git-mind` protocol to propose a change, request approval from a human via the consensus mechanism, and execute the change, all while leaving a perfect audit trail.***

The most exciting potential lies in it being a true "**Operating Surface**" ***for AI***. It provides the **structured**, **reversible**, and **inspectable** "memory" and "motor function" that autonomous agents need to perform complex tasks safely. An AI agent could use the `git-mind` protocol to propose a change, request approval from a human via the consensus mechanism, and execute the change, all while leaving a perfect audit trail.
    
### The Future is Generalization 

> ***... the real success will be when other developers can easily build their own `git-mind`-style applications on the GATOS engine.***

The future of **GATOS** is to become a framework. `git-mind` is the first "killer app," but the real success will be when other developers can easily build their own `git-mind`-style applications on the **GATOS engine**. The work on the bindings crates is the first step on this path.

This project has the potential to be more than just a tool; ***it could be a foundational piece of infrastructure for the next generation of software development and human-AI collaboration*.**

---

## Back to Reality

[SPEC.md](./docs/SPEC.md) â€¢ [TECH-SPEC.md](./docs/TECH-SPEC.md) 

Feet on the ground, head out of the clouds, we are just getting started.

**GATOS** (*Git as the Operating Surfaceâ„¢*) is a new kind of **programmable, distributed backend that uses a standard Git repository as its database, message bus, and source of truth**. It enables a ***"Conversational GitOps"*** workflow where every action, from a user command to an automated process, is recorded as a verifiable, time-addressable commit.

The system is built on a Hexagonal Architecture ("Ports and Adapters"), with a portable `no_std` core that defines the pure business logic, surrounded by "adapters" that connect it to the outside world (like a Git backend or a JSONL server). This makes the core logic highly testable, secure, and capable of running anywhere from a server to a WASM sandbox.

### The Four Planes of GATOS

The architecture is conceptually divided into four distinct planes:

| Plane   | Responsibility         | Crate          |
| ------- | ---------------------- | -------------- |
| Ledger  | Signed events / proofs | `gatos-ledger` |
| State   | Deterministic folds    | `gatos-echo`   |
| Policy  | Rules & capabilities   | `gatos-policy` |
| Message | Bus / sessions         | `gatos-mind`   |

Interaction with the system is handled by the `gatosd` daemon, which exposes a simple JSONL RPC protocol. This allows both human-driven CLIs and automated agents (like LLMs) to "converse" with the repository in a structured, deterministic way.

This design provides several powerful benefits:
  
- **Complete Auditability**: Every state change is a signed commit in the Git history.
- **Time-Travel**: Any previous state can be checked out, inspected, and branched from.
- **Offline-First & Distributed**: The entire state lives within the Git repository, which can be used offline and synchronized via normal `git push/pull`.
- **Policy-Driven Governance**: A flexible policy engine allows for fine-grained control over actions, including multi-party approval workflows ("N of M" consensus).

## Conversations with *GATOS*

### An AI Conversation with *GATOS*

Here's an example of a "conversation" I, as an LLM agent, might have with **GATOS**, using the `git gatos` tool and its JSONL protocol as described in the [origin story](./docs/ok-real-talk.md).

**Scenario**: My goal is to find unresolved review threads from `coderabbitai` in a specific pull request, generate a response for one, and then resolve it. I will interact with **GATOS** by sending JSON commands to the `git gatos serve --stdio` process and receiving JSON responses.

<details>
*(Meta-commentary is in italics)*

***Begin Scene.***

[Me, the LLM Agent]
*First, I need to establish context. I'll ask GATOS to detect the current repository.*

```json
1 {"id": "op-001", "cmd": "repo.detect", "args": {"path": "."}}
```

[GATOS Daemon]
*GATOS detects the repo, creates the first state snapshot commit, and returns the result along with the commit's SHA as `state_ref`.*

```json
1 {"id": "op-001", "ok": true, "state_ref": "9a0bf22...", "result": {"owner": "flyingrobots", "repo": "draft-punks"}}
```

[Me, the LLM Agent]
*Great. Now I'll list the pull requests, filtering for those authored by `coderabbitai` that have unresolved threads. I'll use the `state_ref` from the previous step to ensure I'm working from the correct state.*

```json
1 {"id": "op-002", "cmd": "pr.list", "expect_state": "9a0bf22...", "args": {"author": "coderabbitai", "unresolved": true}}
```

[GATOS Daemon]
*GATOS finds one matching PR, updates the internal state by caching the result and auto-selecting PR #123 (since it's the only match), and commits the new state.*

```json
1 {"id": "op-002", "ok": true, "state_ref": "1d412c9...", "result": {"total": 1, "items": [{"number": 123, "title": "Fix for the main frobnicator"}]}}
```

[Me, the LLM Agent]
*The state now has PR #123 selected. I'll list its unresolved threads. I'll use the new `state_ref` to ensure atomicity.*

```json
1 {"id": "op-003", "cmd": "thread.list", "expect_state": "1d412c9...", "args": {"unresolved": true}}
```

[GATOS Daemon]
*GATOS finds the threads for PR #123, updates the state cache, and returns the list.*

```json
1 {"id": "op-003", "ok": true, "state_ref": "2b71c10...", "result": {"total": 9, "items": [{"id": "MDEx...", "body": "This function could be simplified."}, ...]}}
```

[Me, the LLM Agent]
*Now I'll "run" the first thread through my own logic (simulated here by the `llm.send` command with a debug provider). This is the core "thinking" step.*

```json
1 {"id": "op-004", "cmd": "llm.send", "expect_state": "2b71c10...", "args": {"thread_id": "MDEx...", "provider": "debug", "debug_result": "success"}}
```

[GATOS Daemon]
*GATOS records the result of the LLM operation in its journal (via a commit trailer) and updates the state. It returns the simulated*
*successful outcome.*

```json
1 {"id": "op-004", "ok": true, "state_ref": "3ac2b11...", "result": {"success": true, "output": "Suggested change: `return simplify(foo)`"}}
```

[Me, the LLM Agent]
*The operation was a success. Now I will perform the final, state-changing action: resolving the thread on the remote. This is a side-effect, so I must explicitly confirm it by setting `confirm: true` (the equivalent of the `--yes` flag).*

```json
1 {"id": "op-005", "cmd": "thread.resolve", "expect_state": "3ac2b11...", "args": {"thread_id": "MDEx...", "confirm": true}}
```

[GATOS Daemon]
*GATOS verifies the state, performs the remote action (e.g., calls the GitHub API), and on success, commits the final state change to its internal Git history, creating a permanent, auditable record of the resolution.*

```json
1 {"id": "op-005", "ok": true, "state_ref": "59fd7a4...", "result": {"resolved": true, "thread_id": "MDEx..."}}
```

***End Scene.***
</details>

In this conversation, every step is a small, atomic, and verifiable state change recorded in a Git history. I can stop at any point, and
GATOS will remember the context. If another process were to interact with it, my *expect_state* check would fail, preventing me from acting on stale data. ***This is the power of the "Conversational GitOps" model.***

### A Human Conversation with GATOS

**Scenario**: A developer, James, wants to check on his open pull requests and then look at some automated reviews from `coderabbitai`. He uses the dp alias for git gatos.

<details>
*(Meta-commentary is in italics)*

***Begin Scene.***

[James]
*First, I'll list my own open PRs that have unresolved threads.*

```bash
git dp pr list --author=James --unresolved
```

[GATOS CLI]
*GATOS finds two matching PRs and displays them in a table. The internal state now contains this list of two PRs, but nothing is selected yet.*

```bash
Found 2 pull requests for @James with unresolved threads.

NUM  TITLE                         THREADS  AGE
---  -------------------------     -------  ---
123  Fix for the main frobnicator   3     2d
125  Update documentation           1     5h

To select one, run: git dp pr select <NUM>
```

[James]
*Okay, I want to look at the first one.*

```bash
git dp pr select 123
```

[GATOS CLI]
*The tool updates its state to mark PR #123 as the active selection. This is committed to the internal `refs/mind/sessions/main` history.*

```bash
âœ… Selected PR #123: Fix for the main frobnica...
```

[James]
*Now that I have a PR selected, I can ask for its threads without specifying the PR number again. The tool remembers the context.*

```bash
git dp thread list
```

[GATOS CLI]
*GATOS uses the selected PR from its state to fetch and display only the threads for PR #123.*

```bash
Displaying 3 threads for PR #123.

ID     AUTHOR         BODY
----   ------------   ---------------------------------
T01    coderabbitai   This function could be simplified.
T02    another-dev    Good catch!
T03    coderabbitai   Nit: extra whitespace.
```

[James]
*Okay, I'm done with my PRs for now. I want to switch gears and see what `coderabbitai` has been up to elsewhere. I'll start a new query.*

```bash
git dp pr list --author=coderabbitai
```

[GATOS CLI]
*This is the key moment. Because James initiated a new top-level query (`pr list`), GATOS resets the previous context. The old selection (PR #123) and its cached threads are cleared before running the new command. It finds one PR from `coderabbitai` and, since it's the only result, it's automatically selected.*

```bash
Found 1 pull request for @coderabbitai.

NUM  TITLE                      THREADS  AGE
---  -------------------------  -------  ---
456  Automated dependency update      5  1h

âœ… Auto-selected only result: PR #456. 
```

[James]
*Just to be sure, I'll check the current state.*

```bash
git dp state show
```

[GATOS CLI]
*The output confirms that the state was reset and now reflects the new context.*

```bash
Current GATOS State (Session: main, Ref: 8c03aef...)

REPO
  owner: flyingrobots
  repo:  draft-punks

SELECTION
  pr: 456
```

***End Scene.***
</details>

This flow shows how GATOS acts like a helpful assistant, remembering your context while you're focused on a task, but smartly resetting when you clearly indicate you're starting a new one.

---

## License 

[Apache 2.0](./LICENSE) 

*Â© J. Kirby Ross <james@flyingrobots.dev> [flyingrobots](https://github.com/flyingrobots)*
