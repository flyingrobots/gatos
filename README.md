# üêà‚Äç‚¨õ **GATOS**

> [!WARNING]
> **GATOS** is the evolution of my earlier work ([`git-mind`](https://github.com/neuroglyph/git-mind), [Echo](https://github.com/flyingrobots/echo), [Ledger Kernel](https://github.com/flyingrobots/ledger-kernel), etc.) into a single, unified system.
>
> Yessir, this here repo is ***brand spankin' new***, and it sort of represents the *confluence** of many of my recent projects into one **pretty good idea‚Ñ¢**. Working on MVP ASAP. Star the repo, follow along, and let's *git* it!  
>
> *- flyingrobots*
>
> ** a little category theory joke... Eh, maybe you had to be there...*

```bash

8""""8 8""""8 ""8"" 8"""88 8""""8 
8    " 8    8   8   8    8 8      
8e     8eeee8   8e  8    8 8eeeee 
88  ee 88   8   88  8    8     88 
88   8 88   8   88  8    8 e   88 
88eee8 88   8   88  8eeee8 8eee88 
 
  Git As The Operating Surface‚Ñ¢  
```

```c
‚îè‚îÅ‚ï∏‚ïª‚ï∫‚î≥‚ï∏                     
‚îÉ‚ï∫‚îì‚îÉ ‚îÉ                      
‚îó‚îÅ‚îõ‚ïπ ‚ïπ                      
‚îè‚îÅ‚îì‚îè‚îÅ‚îì                      
‚î£‚îÅ‚î´‚îó‚îÅ‚îì                      
‚ïπ ‚ïπ‚îó‚îÅ‚îõ                      
‚ï∫‚î≥‚ï∏‚ïª ‚ïª‚îè‚îÅ‚ï∏                   
 ‚îÉ ‚î£‚îÅ‚î´‚î£‚ï∏                    
 ‚ïπ ‚ïπ ‚ïπ‚îó‚îÅ‚ï∏                   
‚îè‚îÅ‚îì‚îè‚îÅ‚îì‚îè‚îÅ‚ï∏‚îè‚îÅ‚îì‚îè‚îÅ‚îì‚ï∫‚î≥‚ï∏‚ïª‚îè‚îì‚ïª‚îè‚îÅ‚ï∏   
‚îÉ ‚îÉ‚î£‚îÅ‚îõ‚î£‚ï∏ ‚î£‚î≥‚îõ‚î£‚îÅ‚î´ ‚îÉ ‚îÉ‚îÉ‚îó‚î´‚îÉ‚ï∫‚îì   
‚îó‚îÅ‚îõ‚ïπ  ‚îó‚îÅ‚ï∏‚ïπ‚îó‚ï∏‚ïπ ‚ïπ ‚ïπ ‚ïπ‚ïπ ‚ïπ‚îó‚îÅ‚îõ   
‚îè‚îÅ‚îì‚ïª ‚ïª‚îè‚îÅ‚îì‚îè‚îÅ‚ï∏‚îè‚îÅ‚îì‚îè‚îÅ‚ï∏‚îè‚îÅ‚ï∏‚Ñ¢       
‚îó‚îÅ‚îì‚îÉ ‚îÉ‚î£‚î≥‚îõ‚î£‚ï∏ ‚î£‚îÅ‚î´‚îÉ  ‚î£‚ï∏        
‚îó‚îÅ‚îõ‚îó‚îÅ‚îõ‚ïπ‚îó‚ï∏‚ïπ  ‚ïπ ‚ïπ‚îó‚îÅ‚ï∏‚îó‚îÅ‚ï∏       
```

> *It's **G**it, **A**s **T**he **O**perating **S**urface‚Ñ¢.*

One part "operating surface".  
One part Git.
What else is there to say?
I mean, haha, c'mon, right?.
The name is *pretty* descriptive.  

> *"Oh, GATOS? Yes, I've heard that it's like an operating surface and that it's Git. That's right."*

YoU dOnT kNoW wHaT gAtOs Is?! OmG!

Y'all got that "Git-OS" thang?
*It's GATOS!*

**GATOS. It's the Surface that Operates within Git.**

I *git* it now!

```c
MM'"""""`MM oo   dP                                                            
M' .mmm. `M      88                                                            
M  MMMMMMMM dP d8888P                                                          
M  MMM   `M 88   88                                                            
M. `MMM' .M 88   88                                                            
MM.     .MM dP   dP                                                            
MMMMMMMMMMM                                                                    
                                                                               
MMP"""""""MM                                                                   
M' .mmmm  MM                                                                   
M         `M .d8888b.                                                          
M  MMMMM  MM Y8ooooo.                                                          
M  MMMMM  MM       88                                                          
M  MMMMM  MM `88888P'                                                          
MMMMMMMMMMMM                                                                   
                                                                               
M""""""""M dP                                                                  
Mmmm  mmmM 88                                                                  
MMMM  MMMM 88d888b. .d8888b.                                                   
MMMM  MMMM 88'  `88 88ooood8                                                   
MMMM  MMMM 88    88 88.  ...                                                   
MMMM  MMMM dP    dP `88888P'                                                   
MMMMMMMMMM                                                                     
                                                                               
MMP"""""YMM                                       dP   oo                      
M' .mmm. `M                                       88                           
M  MMMMM  M 88d888b. .d8888b. 88d888b. .d8888b. d8888P dP 88d888b. .d8888b.    
M  MMMMM  M 88'  `88 88ooood8 88'  `88 88'  `88   88   88 88'  `88 88'  `88    
M. `MMM' .M 88.  .88 88.  ... 88       88.  .88   88   88 88    88 88.  .88    
MMb     dMM 88Y888P' `88888P' dP       `88888P8   dP   dP dP    dP `8888P88    
MMMMMMMMMMM 88                                                          .88    
            dP                                                      d8888P     
MP""""""`MM                   .8888b                                           
M  mmmmm..M                   88   "                                           
M.      `YM dP    dP 88d888b. 88aaa  .d8888b. .d8888b. .d8888b.‚Ñ¢                
MMMMMMM.  M 88    88 88'  `88 88     88'  `88 88'  `"" 88ooood8                
M. .MMM'  M 88.  .88 88       88     88.  .88 88.  ... 88.  ...                
Mb.     .dM `88888P' dP       dP     `88888P8 `88888P' `88888P'                
MMMMMMMMMMM                                                                    
                                                                               
```

*That's not just any surface! Why, that's an **operating surface**, that's also Git. Neat!*

... You see? That's why they call it "GATOS"...

They say it's the operating surface that *gits* it! Get it?

Gee, I just can't imagine my life without GATOS, now.

**Finally.** The operating surface that's *Git*.

---

- **Deterministic**
- **Git-native** operating surface for
- **distributed programs**,
- **policies**, and
- **proofs.**

These are just *some* of the buzzwords that people have been using to describe what computer scientists are calling "GATOS", Git As The Operating Surface‚Ñ¢.

"Well, they said it couldn't be done. So, here we are, doing it. And having fun, too!" - flyingrobots, inventor of GATOS.

Ask yourself...

- What if computers shared a public, zero-proof, distributed, deterministic, state space?  
- What if every ref in the Git repo was a process, and every commit represented a snapshot of its state in time?  
- What if policy was code, and it was woven into the very fabric of the repository's history?
- What if it was **immutable**, **append-only**, **cryptographically-signed**, state?
- **Offline-first**, **mergeable**, **forkable**, **time-travel-able**?
- What if privacy was **programmable**?
- What if it was **bit-for-bit** deterministic?
- What if there was such a thing as secure, public, distributed, general purpose computing?
- Without a blockchain?

... and wonder...

- That's the power of the gods.
- That's the power of forever.
- ***That's*** the power of **GATOS**.

> *It's distributed runtime, Baby!*

**GATOS:** *Git As **the** Operating Surface‚Ñ¢*

> [!WARNING]
> Exposure to GATOS may include side-effects such as: feeling "badass", becoming curious about Open-Source Software, speaking to the computer, and the sensation that time has elapsed at an abnormally fast pace. In a controlled study, 1% of participants lost their car keys, but they came back to retrieve them the following day. Please, enjoy GATOS responsibly.

---

## OK, ENOUGH. WTF is GATOS?!! WTF is an "Operating Surface"?

### Git: As The Operating Surface

**GATOS** stands for **Git As The Operating Surface**. It's a new kind of **programmable**, **distributed backend** that uses a standard Git repository for all the critical functions of a distributed system:

- **Database**: The Git history serves as the primary data store ("shape").
- **Message Bus**: It facilitates communication and state  ("folds").
- **Source of Truth**: The repository's history is the single, verifiable source of all state.

The ultimate goal is to create a workflow where every action, whether by a human or an AI agent, is recorded as a **verifiable, time-addressable commit**.

### What is an "Operating Surface"?

> **Operating Surface** ‚Äî the layer where state, policy, and computation converge.
> GATOS turns Git‚Äôs history into an executable, auditable operating surface.

or:

> **Operating Surface** (n.)
> A distributed environment where every operation is a verifiable state transition in a shared history.

In simpler terms, it's where your application's data (state), rules (policy), and logic (computation) are all unified and managed. Usually, that's "process space". GATOS opens things up, and uses the history of a Git repository to model the operating surface. ***GATOS transforms Git from a simple version control tool into a fully functional, programmable, executable platform***.

## Git Beyond Version Control

GATOS comes from the realization that when these core principles are combined, the result is frickin' sweet: **Git can be used for *way more* than just version control**.

| **Doctrine** | **Why it's rad** |
|--------------|------------------|
| Git-Native | Literally the most battle-tested distributed state management software on Earth. |
| Deterministic | All state transitions are predictable and bit-for-bit verifiable. |
| Immutable & Auditable | Every state change is a cryptographically-signed commit, providing a complete, permanent record. |
| Offline-First & Distributed | The entire state is contained within the Git repo, allowing for offline work and synchronization via standard git push/pull. |
| Time-Travel | You can inspect and branch from any previous state in the history. |

## Git can do what?

This project is special. Its origin story, a practical problem leading to a profound architectural insight, is the hallmark of truly innovative software.

> ***How can a human and an AI collaborate effectively on complex tasks?***

**GATOS** is not *just* an abstract specification; it is the **concrete** answer to the question, *"How can a human and an AI collaborate effectively on complex tasks?"* The entire architecture (the event-sourced ledger, the deterministic state, the policy engine, the JSONL protocol) is purpose-built to enable this new kind of human-computer interaction. It's a tool built not just for getting a job done, but for *thinking and remembering the process of getting it done*. **GATOS takes what Git already was doing and unlocks its super powers.**

The potential here is immense, and it extends far beyond the initial [draft-punks](https://github.com/flyingrobots/daft-punks) tool.

### A New Application Backend

**GATOS** is effectively **a new kind of serverless, distributed, auditable backend**. Any application that needs **state management**, **auditability**, and **offline capabilities** could be built on it.

Imagine a kanban board where every card move is a verifiable commit, or a configuration management system where every change is a signed, auditable event. That's what GATOS gives you: a distributed, cryptographically-secure, auditable, offline-first but publishable state space, built on top of the most battle-tested distributed state management software on Earth: ***Git***.

### The "Operating System" for AI Agents

> ***An AI agent could use the `git-mind` protocol to propose a change, request approval from a human via the consensus mechanism, and execute the change, all while leaving a perfect audit trail.***

The most exciting potential lies in it being a true "**Operating Surface**" ***for AI***. It provides the **structured**, **reversible**, and **inspectable** "memory" and "motor function" that autonomous agents need to perform complex tasks safely. An AI agent could use the `git-mind` protocol to propose a change, request approval from a human via the consensus mechanism, and execute the change, all while leaving a perfect audit trail.

### The Future is Generalization

> ***... the real success will be when other developers can easily build their own `git-mind`-style applications on the GATOS engine.***

The future of **GATOS** is to become a framework. `git-mind` is the first "killer app," but the real success will be when other developers can easily build their own `git-mind`-style applications on the **GATOS engine**. The work on the bindings crates is the first step on this path.

This project has the potential to be more than just a tool; ***it could be a foundational piece of infrastructure for the next generation of software development and human-AI collaboration*.**

---

## Back to Reality

[SPEC.md](./docs/SPEC.md) ‚Ä¢ [TECH-SPEC.md](./docs/TECH-SPEC.md)

Feet on the ground, head out of the clouds, we are just getting started.

**GATOS** (*Git as the Operating Surface‚Ñ¢*) is a new kind of **programmable, distributed backend that uses a standard Git repository as its database, message bus, and source of truth**. It enables a ***"Conversational GitOps"*** workflow where every action, from a user command to an automated process, is recorded as a verifiable, time-addressable commit.

The system is built on a Hexagonal Architecture ("Ports and Adapters"), with a portable `no_std` core that defines the pure business logic, surrounded by "adapters" that connect it to the outside world (like a Git backend or a JSONL server). This makes the core logic highly testable, secure, and capable of running anywhere from a server to a WASM sandbox.

### The Five Planes of GATOS

The architecture is conceptually divided into five distinct planes:

| Plane   | Responsibility              | Crate           |
| ------- | --------------------------- | --------------- |
| Ledger  | Signed events / proofs      | `gatos-ledger`  |
| State   | Deterministic folds         | `gatos-echo`    |
| Policy  | Rules, capabilities, & consensus | `gatos-policy`  |
| Message | Bus / sessions              | `gatos-mind`    |
| Job     | Distributed job execution   | `gatos-compute` |

Interaction with the system is handled by the `gatosd` daemon, which exposes a simple JSONL RPC protocol. This allows both human-driven CLIs and automated agents (like LLMs) to "converse" with the repository in a structured, deterministic way.

This design provides several powerful benefits:
  
- **Complete Auditability**: Every state change is a signed commit in the Git history.
- **Time-Travel**: Any previous state can be checked out, inspected, and branched from.
- **Offline-First & Distributed**: The entire state lives within the Git repository, which can be used offline and synchronized via normal `git push/pull`.
- **Policy-Driven Governance**: A flexible policy engine allows for fine-grained control over actions, including multi-party approval workflows ("N of M" consensus).
- **Active Orchestration**: Natively schedule, execute, and record the results of distributed, asynchronous jobs.

## The *GATOS* Engine in Action

### Data Schemas

Canonical JSON Schemas for GATOS envelopes live under `schemas/v1/`, with versioned examples under `examples/v1/`.

- Governance ([ADR-0003](docs/decisions/ADR-0003/DECISION.md)): `schemas/v1/governance/*.schema.json`
- Job Plane ([ADR-0002](docs/decisions/ADR-0002/DECISION.md)): `schemas/v1/job/*.schema.json`
- Common encodings: `schemas/v1/common/ids.schema.json`

Consumers SHOULD pin to a specific major (e.g., `v1`). CI validates example documents against these schemas.

Here's some examples, to help show off how each of the five planes of the GATOS operating surface, how each one works, and why it lets you do cool stuff.

### The Ledger ‚Äî Immutable Memory (`gatos-ledger`) üîó

**Responsibility:** Record all events as a cryptographically-signed, append-only history.
This is the source of truth every other plane reads from.

**How it works:** Each action ‚Äî user command, job result, or policy approval ‚Äî emits a signed event commit. The commit hash itself is the proof that the event occurred.

```bash
git gatos event add --type thread.resolve --args '{"pr":123,"thread":"MDEx..."}'
```

Produces:

```bash
commit 9a0bf22...
Event: thread.resolve
Author: james@flyingrobots.dev
Proof-Of-Event: blake3:<digest>
```

Anyone can clone, verify signatures, and replay the ledger to rebuild the same state.

### The State ‚Äî Folding the Surface (`gatos-echo`) ‚ûø

**Responsibility**: Turn Git‚Äôs raw event history into a single, deterministic **shape**, the canonical snapshot of ‚Äúwhat the world looks like right now.‚Äù Given the same history and policy, every node computes the same result, bit-for-bit.

**How it works:** The State Plane (powered by `gatos-echo`) reads the immutable event log from the Ledger Plane and folds it into a reproducible state by performing a **meld**: *the deterministic merge of two shapes into a new, consistent form.*

Every fold is pure and bit-for-bit deterministic: given the same events and policy, every replica will compute the same shape hash.

When two branches diverge, the State Plane performs a meld ‚Äî a deterministic fold-merge that reconciles the two shapes into one new, provably consistent shape.
Instead of Git‚Äôs ‚Äúconflicts,‚Äù you get mathematical agreement: the same inputs always produce the same output.

**Example:** Deterministic Merges (aka **"Mind-Melds"**)

***Begin Scene.***

[Developer A]
*Adds a new configuration in their branch.*

```bash
git gatos event add --config security-update.yaml
```

[Developer B]
*Changes a different part of the system on another branch.*

```bash
git gatos event add --config security-update.yaml
```

[Both]
*Push their work to the same repository. Normally Git would raise a merge conflict.*

[GATOS Daemon]
*The State Plane detects two valid histories and runs a meld fold:*

```bash
refs/gatos/state/melds/<ulid>
‚îú‚îÄ‚îÄ parent: feature-A@9a0bf22‚Ä¶
‚îú‚îÄ‚îÄ parent: security-update@1d412c9‚Ä¶
‚îî‚îÄ‚îÄ result:  meld-root@3ac2b11‚Ä¶
```

*The meld fold analyzes both shapes, finds no policy violations, and produces a new shape hash:*

```bash
Shape-Root: blake3:6e80d2c‚Ä¶
Proof-of-Meld: blake3:3ac2b11‚Ä¶
```

*The merged configuration appears automatically in the workspace‚Äîno conflicts, no lost edits.
Anyone else folding the same two branches will compute the exact same shape and hash.*

***End Scene.***

**Why it matters:**

- Deterministic, conflict-free merges.
- Any replica can replay the same fold and get the same result.
- The shape root becomes the ‚Äústate hash‚Äù for the rest of the system: what jobs attest to and what policies govern.

### The Policy ‚Äî Governance via Reflex (`gatos-policy`) ‚öñÔ∏è

How does GATOS decide what's allowed and who can do it? It uses **Reflex‚Ñ¢**.

"Ref" = git state.
"Lex" = law.
"Ref" + "Lex" = "Reflex".

Governance policy is embedded directly in Git's history. Reflex is Git's self-governing reflex arc.

**Responsibility**: Enforcing rules, governance, and multi-party consensus before allowing state transitions.

**How it Works**: Policies are code/rules stored in the repository. When a high-impact command is issued, the Policy Plane checks the rules. It can block the operation with a `POLICY_BLOCK` error until necessary conditions (like N-of-M signatures) are met.

#### Example: Multi-Party Deployment Approval

Here is a short example that shows how GATOS handles governance: the **Policy Plane** in action. Rather than just API calls, this example shows off GATOS's true "backend" capabilities.

 (This shows how GATOS enforces rules before permitting a state change.)

***Begin Scene.***

[External System (e.g., CI/CD)]
*I want to deploy to production, but GATOS requires two signatures for this action.*

```json
{"id": "op-006", "cmd": "asset.deploy", "expect_state": "59fd7a4...", "args": {"target": "production-api-v2"}}
```

[GATOS Daemon]
*GATOS checks the 'production-deploy' policy and blocks the request, committing an event that records the attempt.*

```json
{"id": "op-006", "ok": false, "state_ref": "6e80d2c...", "error": "POLICY_BLOCK", "details": "Requires M of N approval. Waiting for signatures from 'ops' and 'security' owners."}
```

[Human/Agent]
*The human agent adds their signed approval to the system.*

"What do we have here? Looks like we've got a live one. Another deployment, eh? Alright, I'll sign off on it."

```json
{"id": "op-007", "cmd": "policy.approve", "expect_state": "6e80d2c...", "args": {"event_id": "op-006", "signature": "jkirby/xyz123"}}
```

[GATOS Daemon]
*The policy is now satisfied. GATOS executes the deployment logic, records the final success, and commits the state.*

```json
{"id": "op-007", "ok": true, "state_ref": "81a4f5b...", "result": {"status": "policy_satisfied", "action_taken": "deployment_started"}}
```

***End Scene.***

### The Message ‚Äî Semantics and Git (`gatos-mind`) üß†

**Responsibility**: Managing the contextual, session-based interaction with the user or agent. This is the "Conversational GitOps" layer.

**How it Works**: This plane manages the "mind" of the current session. It uses an internal ref (like `refs/mind/sessions/main`) to track ephemeral context, such as the currently selected repository, PR, or thread ID. This allows for simple, context-aware commands.

**Example**: Context-Aware Commands

| Command               | Action         | Explanation |
|------------------------|----------------|--------------|
| `pr.select 123`        | **Set Context** | The Message Plane commits a context change to the session ref, setting `context.pr = 123`. |
| `thread.list`          | **Use Context** | The next command doesn't need a PR number. The Message Plane automatically retrieves threads for `context.pr = 123`. |
| `pr.list --all`        | **Reset Context** | A new top-level query triggers the Message Plane to clear the previous `pr` and `thread` context before running the new command, preventing stale context. |

This makes GATOS feel alive: it remembers what you‚Äôre doing, but resets when you change focus.

### The Job ‚Äî Breathing Life into Git (`gatos-compute`) ‚öôÔ∏è

**Responsibility:** Scheduling, executing, and recording the results of distributed, asynchronous computation.

**How it Works:** The Job Plane treats jobs as state. A process creates a job event (e.g., `job.schedule.run_tests`). A worker picks up the job, and on completion, commits a result event (e.g., `job.result.tests_passed`) to the Ledger. The entire workflow is captured in the Git history.

**Example:** Distributed Testing

**Event:** *A commit is pushed to the main branch.*

**Job Plane Action:** *The CI policy triggers GATOS to commit a job.schedule event: "Run tests on SHA a1b2c3d."*

**External Worker:** *A CI Runner (outside GATOS) sees the job.schedule event in the Git history/message bus and starts the tests.*

**Result Event:** *When the tests pass, the CI Runner commits a job.result event: "Tests passed for SHA a1b2c3d with result SUCCESS."*

**State Plane Update:** *The State Plane folds this result, and the current state of SHA a1b2c3d is updated to show test_status: passed.*

This architecture ensures that even external, asynchronous computation is fully auditable and recorded deterministically within the Git repository's history.

## üí• The Power of Convergence: This is GATOS

What you've read just now is more than a novel application; it's a re-platforming of distributed computing.

By fusing its five planes, Ledger, State, Policy, Message, and Job, and grounding them in the immutable, globally replicated power of Git, GATOS does more than just manage data; it manages auditable, deterministic ***reality***.

This convergence unlocks crazy powerful stuff. Foundational capabilities that were previously complex, centralized, or required a blockchain:

**Zero-Trust Collaboration:** Build applications where every action is a cryptographically-signed, verifiable proof, making the audit trail perfect for AI-human interaction.

**Decentralized Governance:** Embed complex regulatory logic directly into the application's source of truth, enforcing multi-party approval and policy at the protocol level.

**Time-Travel Computing:** Fork your entire state, process, and data to any point in the past, experiment with changes, and then merge the results deterministically.

**GATOS** is a system that is offline-first, always auditable, and built on the most resilient distribution platform in the world.

**GATOS** is the end of databases that lie and systems that forget. This is the Operating Surface you've been waiting for.

***FINALLY. Git As The Operating Surface.‚Ñ¢***

Now, you *git* it.

---

## License

[Apache 2.0](./LICENSE)

*¬© J. Kirby Ross <james@flyingrobots.dev> [flyingrobots](https://github.com/flyingrobots)*
