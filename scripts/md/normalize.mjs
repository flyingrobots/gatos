#!/usr/bin/env node
// Normalize Markdown files via unified/remark:
// - parse → apply plugins → stringify
// - insert TOC between <!-- AUTOGENERATED TOC START/END --> markers
// - add stable anchors (slug + optional numeric) exactly once per heading
// - linkify SPEC/TECH-SPEC § references
// - fix nested relative links to absolute site paths

import { unified } from 'unified'
import remarkParse from 'remark-parse'
import remarkStringify from 'remark-stringify'
import remarkGfm from 'remark-gfm'
import remarkFrontmatter from 'remark-frontmatter'
import { visit } from 'unist-util-visit'
import { toString } from 'mdast-util-to-string'
import { globby } from 'globby'
import fs from 'node:fs/promises'
import path from 'node:path'

const ROOT = path.resolve(process.cwd())
const DOCS = path.join(ROOT, 'docs')

const START = '<!-- AUTOGENERATED TOC START -->'
const END = '<!-- AUTOGENERATED TOC END -->'

// NOTE: Anchor IDs and TOCs are managed by scripts/anchors_and_toc.py and
// existing inline HTML. normalize.mjs intentionally leaves anchors unchanged
// to avoid fighting that pipeline; it only maintains the TOC block shape when
// present and applies SPEC/TECH-SPEC/link fixes.

function anchorsMulti() {
  // No-op: rely on existing <a id="..."></a> anchors managed elsewhere.
  return () => {}
}

function tocMarkers() {
  return (tree, file) => {
    const nodes = tree.children
    let start = -1
    let end = -1
    for (let i = 0; i < nodes.length; i++) {
      const n = nodes[i]
      if (n.type === 'html' && typeof n.value === 'string') {
        if (n.value.includes(START)) start = i
        if (n.value.includes(END)) {
          end = i
          break
        }
      }
    }
    if (start >= 0 && end > start) {
      // TOC exists; leave it as-is to avoid churn. We only care that markers
      // remain present and ordered, which is already true in the source.
      return
    }
  }
}

function linkifySpec() {
  const SPEC = /\bSPEC\s*§\s*(\d+(?:\.(?:\d+|x))?)\b/g
  const TECH = /\bTECH-SPEC\s*§\s*(\d+(?:\.(?:\d+|x))?)\b/g
  return (tree) => {
    visit(tree, (node, index, parent) => {
      if (node.type !== 'text' || !parent || parent.type === 'link' || parent.type === 'inlineCode' || parent.type === 'code') return
      let value = node.value
      if (!value) return
      const replace = (re, base) => {
        value = value.replace(re, (_, s) => `[${base} §${s}](/${base.replace(/-/g, '')}#${s})`)
      }
      const before = value
      replace(SPEC, 'SPEC')
      replace(TECH, 'TECH-SPEC')
      if (value !== before) parent.children[index] = { type: 'text', value }
    })
  }
}

function pathFixer() {
  return (tree, file) => {
    // Convert ./SPEC.md -> /SPEC style; only in link nodes
    visit(tree, 'link', (n) => {
      if (typeof n.url !== 'string') return
      n.url = n.url
        .replace(/^\.\/SPEC\.md(#.*)?$/, '/SPEC$1' )
        .replace(/^\.\/TECH-SPEC\.md(#.*)?$/, '/TECH-SPEC$1' )
    })
  }
}

async function processOne(absPath, write) {
  const orig = await fs.readFile(absPath, 'utf8')
  const file = await unified()
    .use(remarkParse)
    .use(remarkFrontmatter, ['yaml'])
    .use(remarkGfm)
    .use(anchorsMulti)
    .use(tocMarkers)
    .use(linkifySpec)
    .use(pathFixer)
    .use(remarkStringify, {
      bullet: '-',
      fences: true,
      listItemIndent: 'one',
      rule: '-',
      tightDefinitions: true,
      // keep our inline HTML anchor blocks
      allowDangerousHtml: true
    })
    .process({ path: absPath, value: orig })

  const out = String(file)
  const same = out === orig
  if (write && !same) {
    await fs.writeFile(absPath, out, 'utf8')
  } else if (!write && !same) {
    console.error('[normalize] would change:', absPath)
  }
  return same
}

async function main() {
  const write = process.argv.includes('--write')
  const check = process.argv.includes('--check')
  const patterns = process.argv.filter((a) => !a.startsWith('--')).slice(2)
  const globs = patterns.length ? patterns : [path.join('docs', '**/*.md')]
  const files = await globby(globs, { gitignore: true })
  let ok = true
  for (const rel of files) {
    const abs = path.resolve(rel)
    const same = await processOne(abs, write)
    if (!same) ok = false
  }
  if (check && !ok) {
    console.error('[normalize] differences found; run docs:normalize to update')
    process.exit(2)
  }
}

main().catch((e) => { console.error(e); process.exit(1) })
