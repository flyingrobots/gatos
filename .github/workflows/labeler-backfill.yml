name: Labeler Backfill

on:
  workflow_dispatch:

permissions:
  contents: read
  issues: write

jobs:
  backfill:
    runs-on: ubuntu-latest
    steps:
      - name: Backfill labels on unlabeled open issues
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            async function listOpenIssues(page=1) {
              return await github.paginate(github.rest.issues.listForRepo, { owner, repo, state: 'open', per_page: 100 });
            }

            function computeLabels(title, body) {
              const t = (title || '').toLowerCase();
              const b = (body || '').toLowerCase();
              const text = t + '\n' + b;
              const out = new Set();
              if (/\b(p0|priority 0|blocker)\b/.test(text)) out.add('priority: p0');
              else if (/\b(p1|priority 1)\b/.test(text)) out.add('priority: p1');
              else if (/\b(p2|priority 2)\b/.test(text)) out.add('priority: p2');
              if (/(panic|crash|bug|regression|error:)/.test(text)) out.add('type: bug');
              if (/(feature|enhancement|improv|support.*new|add.*support)/.test(text)) out.add('type: enhancement');
              if (/(docs|readme|markdown|typo|spelling)/.test(text)) out.add('type: docs');
              if (/(xtask)/.test(text)) out.add('area: xtask');
              if (/(schema|ajv|json\s*schema|ids\.schema\.json)/.test(text)) out.add('area: schemas');
              if (/(mermaid|diagram|mmdc|puppeteer)/.test(text)) out.add('area: diagrams');
              if (/(github actions|workflow|ci\.yml|pipeline|action)/.test(text)) out.add('area: ci');
              if (/(makefile|cargo build|toolchain|rustup|rust-toolchain)/.test(text)) out.add('area: build');
              if (/(good first issue)/.test(text)) out.add('good first issue');
              if (/(help wanted|looking for help)/.test(text)) out.add('help wanted');
              if (/(blocked|waiting on|dependent on)/.test(text)) out.add('status: blocked');
              if (/(need[s]? more info|clarify|repro steps|cannot reproduce)/.test(text)) out.add('needs: info');
              if (/(repro|minimal reproduction|sample project)/.test(text)) out.add('needs: repro');
              return [...out];
            }

            const issues = await listOpenIssues();
            for (const iss of issues) {
              const current = (iss.labels || []).map(l => typeof l === 'string' ? l : l.name);
              const inferred = computeLabels(iss.title, iss.body).filter(n => !current.includes(n));
              if (inferred.length === 0) continue;
              await github.rest.issues.addLabels({ owner, repo, issue_number: iss.number, labels: inferred });
              core.info(`Issue #${iss.number}: added ${inferred.join(', ')}`);
            }
